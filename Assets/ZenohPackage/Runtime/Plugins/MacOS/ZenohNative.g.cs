#if UNITY_STANDALONE_MACOSX || UNITY_EDITOR_OSX

// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace Zenoh.Plugins
{
    internal static unsafe partial class ZenohNative
    {
#if UNITY_IOS && !UNITY_EDITOR
        const string __DllName = "__Internal";
#else
        const string __DllName = "zenohc";
#endif
        

        internal const ulong DEFAULT_SCOUTING_TIMEOUT = 1000;


        /// <summary>
        ///  Constructs a queryable in its gravestone value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_queryable_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_queryable_null(z_owned_queryable_t* this_);

        [DllImport(__DllName, EntryPoint = "z_queryable_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_queryable_t* z_queryable_loan(z_owned_queryable_t* this_);

        /// <summary>
        ///  Constructs query in its gravestone value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_query_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_query_null(z_owned_query_t* this_);

        /// <summary>
        ///  Returns `false` if `this` is in a gravestone state, `true` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_query_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_query_check(z_owned_query_t* query);

        /// <summary>
        ///  Borrows the query.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_query_t* z_query_loan(z_owned_query_t* this_);

        /// <summary>
        ///  Mutably borrows the query.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_query_t* z_query_loan_mut(z_owned_query_t* this_);

        /// <summary>
        ///  Takes ownership of the mutably borrowed query
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_take_from_loaned", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_query_take_from_loaned(z_owned_query_t* dst, z_loaned_query_t* src);

        /// <summary>
        ///  Destroys the query resetting it to its gravestone value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_query_drop(z_moved_query_t* this_);

        /// <summary>
        ///  Constructs a shallow copy of the query, allowing to keep it in an "open" state past the callback's return.
        ///
        ///  This operation is infallible, but may return a gravestone value if `query` itself was a gravestone value (which cannot be the case in a callback).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_query_clone(z_owned_query_t* dst, z_loaned_query_t* this_);

        /// <summary>
        ///  Constructs the default value for `z_query_reply_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_queryable_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_queryable_options_default(z_queryable_options_t* this_);

        /// <summary>
        ///  Constructs the default value for `z_query_reply_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_reply_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_query_reply_options_default(z_query_reply_options_t* this_);

        /// <summary>
        ///  Constructs the default value for `z_query_reply_err_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_reply_err_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_query_reply_err_options_default(z_query_reply_err_options_t* @this);

        /// <summary>
        ///  Constructs the default value for `z_query_reply_del_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_reply_del_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_query_reply_del_options_default(z_query_reply_del_options_t* @this);

        /// <summary>
        ///  Constructs a Queryable for the given key expression.
        ///
        ///  @param session: A Zenoh session.
        ///  @param queryable: An uninitialized memory location where queryable will be constructed.
        ///  @param key_expr: The key expression the Queryable will reply to.
        ///  @param callback: The callback function that will be called each time a matching query is received. Its ownership is passed to queryable.
        ///  @param options: Options for the queryable.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case )
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_declare_queryable", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_declare_queryable(z_loaned_session_t* session, z_owned_queryable_t* queryable, z_loaned_keyexpr_t* key_expr, z_moved_closure_query_t* callback, z_queryable_options_t* options);

        /// <summary>
        ///  Declares a background queryable for a given keyexpr. The queryable callback will be be called
        ///  to proccess incoming queries until the corresponding session is closed or dropped.
        ///
        ///  @param session: The zenoh session.
        ///  @param key_expr: The key expression the Queryable will reply to.
        ///  @param callback: The callback function that will be called each time a matching query is received. Its ownership is passed to queryable.
        ///  @param options: Options for the queryable.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case )
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_declare_background_queryable", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_declare_background_queryable(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_moved_closure_query_t* callback, z_queryable_options_t* options);

        /// <summary>
        ///  Undeclares queryable callback and resets it to its gravestone state.
        ///  This is equivalent to calling `z_undeclare_queryable()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_queryable_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_queryable_drop(z_moved_queryable_t* this_);

        /// <summary>
        ///  Returns ``true`` if queryable is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_queryable_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_queryable_check(z_owned_queryable_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the ID of the queryable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_queryable_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_entity_global_id_t z_queryable_id(z_loaned_queryable_t* queryable);

        /// <summary>
        ///  Sends a reply to a query.
        ///
        ///  This function must be called inside of a Queryable callback passing the
        ///  query received as parameters of the callback function. This function can
        ///  be called multiple times to send multiple replies to a query. The reply
        ///  will be considered complete when the Queryable callback returns.
        ///
        ///  @param this_: The query to reply to.
        ///  @param key_expr: The key of this reply.
        ///  @param payload: The payload of this reply. Will be consumed.
        ///  @param options: The options of this reply. All owned fields will be consumed.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_reply", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_query_reply(z_loaned_query_t* @this, z_loaned_keyexpr_t* key_expr, z_moved_bytes_t* payload, z_query_reply_options_t* options);

        /// <summary>
        ///  Sends a error reply to a query.
        ///
        ///  This function must be called inside of a Queryable callback passing the
        ///  query received as parameters of the callback function. This function can
        ///  be called multiple times to send multiple replies to a query. The reply
        ///  will be considered complete when the Queryable callback returns.
        ///
        ///  @param this_: The query to reply to.
        ///  @param payload: The payload carrying error message. Will be consumed.
        ///  @param options: The options of this reply. All owned fields will be consumed.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_reply_err", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_query_reply_err(z_loaned_query_t* @this, z_moved_bytes_t* payload, z_query_reply_err_options_t* options);

        /// <summary>
        ///  Sends a delete reply to a query.
        ///
        ///  This function must be called inside of a Queryable callback passing the
        ///  query received as parameters of the callback function. This function can
        ///  be called multiple times to send multiple replies to a query. The reply
        ///  will be considered complete when the Queryable callback returns.
        ///
        ///  @param this_: The query to reply to.
        ///  @param key_expr: The key of this delete reply.
        ///  @param options: The options of this delete reply. All owned fields will be consumed.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_reply_del", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_query_reply_del(z_loaned_query_t* @this, z_loaned_keyexpr_t* key_expr, z_query_reply_del_options_t* options);

        /// <summary>
        ///  Gets query key expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* z_query_keyexpr(z_loaned_query_t* this_);

        /// <summary>
        ///  Gets query &lt;a href="https://github.com/eclipse-zenoh/roadmap/tree/main/rfcs/ALL/Selectors"&gt;value selector&lt;/a&gt;.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_parameters", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_query_parameters(z_loaned_query_t* @this, z_view_string_t* parameters);

        /// <summary>
        ///  Gets query &lt;a href="https://github.com/eclipse-zenoh/roadmap/blob/main/rfcs/ALL/Query%20Payload.md"&gt;payload&lt;/a&gt;.
        ///
        ///  Returns NULL if query does not contain a payload.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_payload", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_query_payload(z_loaned_query_t* this_);

        /// <summary>
        ///  Gets mutable query &lt;a href="https://github.com/eclipse-zenoh/roadmap/blob/main/rfcs/ALL/Query%20Payload.md"&gt;payload&lt;/a&gt;.
        ///
        ///  Returns NULL if query does not contain a payload.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_payload_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_query_payload_mut(z_loaned_query_t* this_);

        /// <summary>
        ///  Gets query &lt;a href="https://github.com/eclipse-zenoh/roadmap/blob/main/rfcs/ALL/Query%20Payload.md"&gt;payload encoding&lt;/a&gt;.
        ///
        ///  Returns NULL if query does not contain an encoding.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_encoding", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_query_encoding(z_loaned_query_t* this_);

        /// <summary>
        ///  Gets query attachment.
        ///
        ///  Returns NULL if query does not contain an attachment.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_attachment", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_query_attachment(z_loaned_query_t* this_);

        /// <summary>
        ///  Gets mutable query attachment.
        ///
        ///  Returns NULL if query does not contain an attachment.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_attachment_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_query_attachment_mut(z_loaned_query_t* this_);

        /// <summary>
        ///  Undeclares a `z_owned_queryable_t`.
        ///  Returns 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_undeclare_queryable", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_undeclare_queryable(z_moved_queryable_t* this_);

        /// <summary>
        ///  Borrows session.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_session_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_session_t* z_session_loan(z_owned_session_t* this_);

        [DllImport(__DllName, EntryPoint = "z_session_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_session_t* z_session_loan_mut(z_owned_session_t* this_);

        /// <summary>
        ///  Constructs a Zenoh session in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_session_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_session_null(z_owned_session_t* this_);

        /// <summary>
        ///  Constructs the default value for `z_open_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_open_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_open_options_default(z_open_options_t* this_);

        /// <summary>
        ///  Constructs and opens a new Zenoh session.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case the session will be in its gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_open", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_open(z_owned_session_t* @this, z_moved_config_t* config, z_open_options_t* _options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs and opens a new Zenoh session with specified client storage.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case the session will be in its gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_open_with_custom_shm_clients", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_open_with_custom_shm_clients(z_owned_session_t* @this, z_moved_config_t* config, z_loaned_shm_client_storage_t* shm_clients);

        /// <summary>
        ///  Returns ``true`` if `session` is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_session_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_session_check(z_owned_session_t* this_);

        /// <summary>
        ///  Constructs the default value for `z_close_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_close_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_close_options_default(z_close_options_t* this_);

        /// <summary>
        ///  Closes Zenoh session. This also drops all the closure callbacks remaining from not yet dropped or undeclared Zenoh entites (subscribers, queriers, etc).
        ///  After this operation, all calls for network operations for entites declared on this session will return a error.
        ///
        ///  @return `0` in case of success, a negative value if an error occured while closing the session.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_close", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_close(z_loaned_session_t* session, z_close_options_t* options);

        /// <summary>
        ///  Checks if zenoh session is closed.
        ///
        ///  @return `true` if session is closed, `false` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_session_is_closed", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_session_is_closed(z_loaned_session_t* session);

        /// <summary>
        ///  Closes and invalidates the session.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_session_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_session_drop(z_moved_session_t* this_);

        /// <summary>
        ///  Constructs a subscriber in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_subscriber_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_subscriber_null(z_owned_subscriber_t* this_);

        /// <summary>
        ///  Borrows subscriber.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_subscriber_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_subscriber_t* z_subscriber_loan(z_owned_subscriber_t* this_);

        /// <summary>
        ///  Constructs the default value for `z_subscriber_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_subscriber_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_subscriber_options_default(z_subscriber_options_t* this_);

        /// <summary>
        ///  Constructs and declares a subscriber for a given key expression. Dropping subscriber undeclares its callback.
        ///
        ///  @param session: The zenoh session.
        ///  @param subscriber: An uninitialized location in memory, where subscriber will be constructed.
        ///  @param key_expr: The key expression to subscribe.
        ///  @param callback: The callback function that will be called each time a data matching the subscribed expression is received.
        ///  @param options: The options to be passed to the subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case subscriber will be in its gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_declare_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_declare_subscriber(z_loaned_session_t* session, z_owned_subscriber_t* subscriber, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, z_subscriber_options_t* options);

        /// <summary>
        ///  Constructs and declares a background subscriber. Subscriber callback will be called to process the messages,
        ///  until the corresponding session is closed or dropped.
        ///
        ///  @param session: The zenoh session.
        ///  @param key_expr: The key expression to subscribe.
        ///  @param callback: The callback function that will be called each time a data matching the subscribed expression is received.
        ///  @param options: The options to be passed to the subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_declare_background_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_declare_background_subscriber(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, z_subscriber_options_t* options);

        /// <summary>
        ///  Returns the key expression of the subscriber.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_subscriber_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* z_subscriber_keyexpr(z_loaned_subscriber_t* subscriber);

        /// <summary>
        ///  Undeclares subscriber callback and resets it to its gravestone state.
        ///  This is equivalent to calling `z_undeclare_subscriber()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_subscriber_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_subscriber_drop(z_moved_subscriber_t* this_);

        /// <summary>
        ///  Returns ``true`` if subscriber is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_subscriber_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_subscriber_check(z_owned_subscriber_t* this_);

        /// <summary>
        ///  Undeclares the subscriber.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_undeclare_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_undeclare_subscriber(z_moved_subscriber_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the ID of the subscriber.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_subscriber_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_entity_global_id_t z_subscriber_id(z_loaned_subscriber_t* subscriber);

        /// <summary>
        ///  @brief Blocking wait on close handle to complete. Returns `Z_EIO` if close finishes with error.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_concurrent_close_handle_wait", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_concurrent_close_handle_wait(zc_moved_concurrent_close_handle_t* handle);

        /// <summary>
        ///  @brief Drops the close handle. The concurrent close task will not be interrupted.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_concurrent_close_handle_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_concurrent_close_handle_drop(zc_moved_concurrent_close_handle_t* this_);

        /// <summary>
        ///  @brief Returns ``true`` if concurrent close handle is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_internal_concurrent_close_handle_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool zc_internal_concurrent_close_handle_check(zc_owned_concurrent_close_handle_t* this_);

        /// <summary>
        ///  @brief Constructs concurrent close handle in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_internal_concurrent_close_handle_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_internal_concurrent_close_handle_null(zc_owned_concurrent_close_handle_t* this_);

        /// <summary>
        ///  Constructs a `z_owned_encoding_t` from a specified substring.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_encoding_from_substr(z_owned_encoding_t* @this, byte* s, nuint len);

        /// <summary>
        ///  Set a schema to this encoding from a c substring. Zenoh does not define what a schema is and its semantichs is left to the implementer.
        ///  E.g. a common schema for `text/plain` encoding is `utf-8`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_set_schema_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_encoding_set_schema_from_substr(z_loaned_encoding_t* @this, byte* s, nuint len);

        /// <summary>
        ///  Set a schema to this encoding from a c string. Zenoh does not define what a schema is and its semantichs is left to the implementer.
        ///  E.g. a common schema for `text/plain` encoding is `utf-8`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_set_schema_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_encoding_set_schema_from_str(z_loaned_encoding_t* @this, byte* s);

        /// <summary>
        ///  Constructs a `z_owned_encoding_t` from a specified string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_encoding_from_str(z_owned_encoding_t* @this, byte* s);

        /// <summary>
        ///  Constructs an owned non-null-terminated string from encoding
        ///
        ///  @param this_: Encoding.
        ///  @param out_str: Uninitialized memory location where a string to be constructed.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_to_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_encoding_to_string(z_loaned_encoding_t* @this, z_owned_string_t* out_str);

        /// <summary>
        ///  Returns a loaned default `z_loaned_encoding_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_loan_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_loan_default();

        /// <summary>
        ///  Constructs a default `z_owned_encoding_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_encoding_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_encoding_null(z_owned_encoding_t* this_);

        /// <summary>
        ///  Frees the memory and resets the encoding it to its default value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_encoding_drop(z_moved_encoding_t* this_);

        /// <summary>
        ///  Returns ``true`` if encoding is in non-default state, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_encoding_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_encoding_check(z_owned_encoding_t* this_);

        /// <summary>
        ///  Borrows encoding.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_loan(z_owned_encoding_t* this_);

        /// <summary>
        ///  Mutably borrows encoding.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_loan_mut(z_owned_encoding_t* this_);

        /// <summary>
        ///  Constructs an owned copy of the encoding in provided uninitilized memory location.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_encoding_clone(z_owned_encoding_t* dst, z_loaned_encoding_t* @this);

        /// <summary>
        ///  Returns ``true`` if `this_` equals to `other`, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_equals", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_encoding_equals(z_loaned_encoding_t* this_, z_loaned_encoding_t* other);

        /// <summary>
        ///  Just some bytes.
        ///
        ///  Constant alias for string: `"zenoh/bytes"`.
        ///
        ///  This encoding supposes that the payload was created with `z_bytes_from_buf()`, `z_bytes_from_slice()` or
        ///  similar functions and its data can be accessed via `z_bytes_to_slice()`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_zenoh_bytes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_zenoh_bytes();

        /// <summary>
        ///  A UTF-8 string.
        ///
        ///  Constant alias for string: `"zenoh/string"`.
        ///
        ///  This encoding supposes that the payload was created with `z_bytes_from_str()`, `z_bytes_from_string()` or
        ///  similar functions and its data can be accessed via `z_bytes_to_string()`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_zenoh_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_zenoh_string();

        /// <summary>
        ///  Zenoh serialized data.
        ///
        ///  Constant alias for string: `"zenoh/serialized"`.
        ///
        ///  This encoding supposes that the payload was created with serialization functions.
        ///  The `schema` field may contain the details of serialziation format.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_zenoh_serialized", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_zenoh_serialized();

        /// <summary>
        ///  An application-specific stream of bytes.
        ///
        ///  Constant alias for string: `"application/octet-stream"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_octet_stream", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_octet_stream();

        /// <summary>
        ///  A textual file.
        ///
        ///  Constant alias for string: `"text/plain"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_plain", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_plain();

        /// <summary>
        ///  JSON data intended to be consumed by an application.
        ///
        ///  Constant alias for string: `"application/json"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_json", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_json();

        /// <summary>
        ///  JSON data intended to be human readable.
        ///
        ///  Constant alias for string: `"text/json"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_json", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_json();

        /// <summary>
        ///  A Common Data Representation (CDR)-encoded data.
        ///
        ///  Constant alias for string: `"application/cdr"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_cdr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_cdr();

        /// <summary>
        ///  A Concise Binary Object Representation (CBOR)-encoded data.
        ///
        ///  Constant alias for string: `"application/cbor"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_cbor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_cbor();

        /// <summary>
        ///  YAML data intended to be consumed by an application.
        ///
        ///  Constant alias for string: `"application/yaml"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_yaml", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_yaml();

        /// <summary>
        ///  YAML data intended to be human readable.
        ///
        ///  Constant alias for string: `"text/yaml"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_yaml", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_yaml();

        /// <summary>
        ///  JSON5 encoded data that are human readable.
        ///
        ///  Constant alias for string: `"text/json5"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_json5", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_json5();

        /// <summary>
        ///  A Python object serialized using [pickle](https://docs.python.org/3/library/pickle.html).
        ///
        ///  Constant alias for string: `"application/python-serialized-object"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_python_serialized_object", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_python_serialized_object();

        /// <summary>
        ///  An application-specific protobuf-encoded data.
        ///
        ///  Constant alias for string: `"application/protobuf"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_protobuf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_protobuf();

        /// <summary>
        ///  A Java serialized object.
        ///
        ///  Constant alias for string: `"application/java-serialized-object"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_java_serialized_object", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_java_serialized_object();

        /// <summary>
        ///  An [openmetrics](https://github.com/OpenObservability/OpenMetrics) data, common used by [Prometheus](https://prometheus.io/).
        ///
        ///  Constant alias for string: `"application/openmetrics-text"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_openmetrics_text", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_openmetrics_text();

        /// <summary>
        ///  A Portable Network Graphics (PNG) image.
        ///
        ///  Constant alias for string: `"image/png"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_image_png", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_image_png();

        /// <summary>
        ///  A Joint Photographic Experts Group (JPEG) image.
        ///
        ///  Constant alias for string: `"image/jpeg"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_image_jpeg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_image_jpeg();

        /// <summary>
        ///  A Graphics Interchange Format (GIF) image.
        ///
        ///  Constant alias for string: `"image/gif"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_image_gif", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_image_gif();

        /// <summary>
        ///  A BitMap (BMP) image.
        ///
        ///  Constant alias for string: `"image/bmp"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_image_bmp", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_image_bmp();

        /// <summary>
        ///  A Web Portable (WebP) image.
        ///
        ///   Constant alias for string: `"image/webp"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_image_webp", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_image_webp();

        /// <summary>
        ///  An XML file intended to be consumed by an application..
        ///
        ///  Constant alias for string: `"application/xml"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_xml", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_xml();

        /// <summary>
        ///  An encoded a list of tuples, each consisting of a name and a value.
        ///
        ///  Constant alias for string: `"application/x-www-form-urlencoded"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_x_www_form_urlencoded", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_x_www_form_urlencoded();

        /// <summary>
        ///  An HTML file.
        ///
        ///  Constant alias for string: `"text/html"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_html", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_html();

        /// <summary>
        ///  An XML file that is human readable.
        ///
        ///  Constant alias for string: `"text/xml"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_xml", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_xml();

        /// <summary>
        ///  A CSS file.
        ///
        ///  Constant alias for string: `"text/css"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_css", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_css();

        /// <summary>
        ///  A JavaScript file.
        ///
        ///  Constant alias for string: `"text/javascript"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_javascript", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_javascript();

        /// <summary>
        ///  A MarkDown file.
        ///
        ///  Constant alias for string: `"text/markdown"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_markdown", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_markdown();

        /// <summary>
        ///  A CSV file.
        ///
        ///  Constant alias for string: `"text/csv"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_text_csv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_text_csv();

        /// <summary>
        ///  An application-specific SQL query.
        ///
        ///  Constant alias for string: `"application/sql"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_sql", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_sql();

        /// <summary>
        ///  Constrained Application Protocol (CoAP) data intended for CoAP-to-HTTP and HTTP-to-CoAP proxies.
        ///
        ///  Constant alias for string: `"application/coap-payload"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_coap_payload", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_coap_payload();

        /// <summary>
        ///  Defines a JSON document structure for expressing a sequence of operations to apply to a JSON document.
        ///
        ///  Constant alias for string: `"application/json-patch+json"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_json_patch_json", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_json_patch_json();

        /// <summary>
        ///  A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8.
        ///
        ///  Constant alias for string: `"application/json-seq"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_json_seq", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_json_seq();

        /// <summary>
        ///  A JSONPath defines a string syntax for selecting and extracting JSON values from within a given JSON value.
        ///
        ///  Constant alias for string: `"application/jsonpath"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_jsonpath", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_jsonpath();

        /// <summary>
        ///  A JSON Web Token (JWT).
        ///
        ///  Constant alias for string: `"application/jwt"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_jwt", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_jwt();

        /// <summary>
        ///  An application-specific MPEG-4 encoded data, either audio or video.
        ///
        ///  Constant alias for string: `"application/mp4"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_mp4", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_mp4();

        /// <summary>
        ///  A SOAP 1.2 message serialized as XML 1.0.
        ///
        ///  Constant alias for string: `"application/soap+xml"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_soap_xml", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_soap_xml();

        /// <summary>
        ///  A YANG-encoded data commonly used by the Network Configuration Protocol (NETCONF).
        ///
        ///  Constant alias for string: `"application/yang"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_application_yang", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_application_yang();

        /// <summary>
        ///  A MPEG-4 Advanced Audio Coding (AAC) media.
        ///
        ///  Constant alias for string: `"audio/aac"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_audio_aac", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_audio_aac();

        /// <summary>
        ///  A Free Lossless Audio Codec (FLAC) media.
        ///
        ///  Constant alias for string: `"audio/flac"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_audio_flac", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_audio_flac();

        /// <summary>
        ///  An audio codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.
        ///
        ///  Constant alias for string: `"audio/mp4"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_audio_mp4", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_audio_mp4();

        /// <summary>
        ///  An Ogg-encapsulated audio stream.
        ///
        ///  Constant alias for string: `"audio/ogg"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_audio_ogg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_audio_ogg();

        /// <summary>
        ///  A Vorbis-encoded audio stream.
        ///
        ///  Constant alias for string: `"audio/vorbis"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_audio_vorbis", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_audio_vorbis();

        /// <summary>
        ///  A h261-encoded video stream.
        ///
        ///  Constant alias for string: `"video/h261"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_h261", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_h261();

        /// <summary>
        ///  A h263-encoded video stream.
        ///
        ///  Constant alias for string: `"video/h263"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_h263", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_h263();

        /// <summary>
        ///  A h264-encoded video stream.
        ///
        ///  Constant alias for string: `"video/h264"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_h264", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_h264();

        /// <summary>
        ///  A h265-encoded video stream.
        ///
        ///  Constant alias for string: `"video/h265"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_h265", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_h265();

        /// <summary>
        ///  A h266-encoded video stream.
        ///
        ///  Constant alias for string: `"video/h266"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_h266", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_h266();

        /// <summary>
        ///  A video codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.
        ///
        ///  Constant alias for string: `"video/mp4"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_mp4", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_mp4();

        /// <summary>
        ///  An Ogg-encapsulated video stream.
        ///
        ///  Constant alias for string: `"video/ogg"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_ogg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_ogg();

        /// <summary>
        ///  An uncompressed, studio-quality video stream.
        ///
        ///  Constant alias for string: `"video/raw"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_raw", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_raw();

        /// <summary>
        ///  A VP8-encoded video stream.
        ///
        ///  Constant alias for string: `"video/vp8"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_vp8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_vp8();

        /// <summary>
        ///  A VP9-encoded video stream.
        ///
        ///  Constant alias for string: `"video/vp9"`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_encoding_video_vp9", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_encoding_video_vp9();

        [DllImport(__DllName, EntryPoint = "zc_internal_encoding_get_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern zc_internal_encoding_data_t zc_internal_encoding_get_data(z_loaned_encoding_t* @this);

        [DllImport(__DllName, EntryPoint = "zc_internal_encoding_from_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_internal_encoding_from_data(z_owned_encoding_t* @this, zc_internal_encoding_data_t data);

        /// <summary>
        ///  Borrows config.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_config_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_config_t* z_config_loan(z_owned_config_t* this_);

        /// <summary>
        ///  Mutably borrows config.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_config_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_config_t* z_config_loan_mut(z_owned_config_t* this_);

        /// <summary>
        ///  Constructs a new empty configuration.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_config_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_config_default(z_owned_config_t* this_);

        /// <summary>
        ///  Constructs config in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_config_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_config_null(z_owned_config_t* this_);

        /// <summary>
        ///  Clones the config into provided uninitialized memory location.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_config_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_config_clone(z_owned_config_t* dst, z_loaned_config_t* @this);

        /// <summary>
        ///  Gets the property with the given path key from the configuration, and constructs and owned string from it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_get_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_get_from_str(z_loaned_config_t* @this, byte* key, z_owned_string_t* out_value_string);

        /// <summary>
        ///  Gets the property with the given path key from the configuration, and constructs and owned string from it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_get_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_get_from_substr(z_loaned_config_t* @this, byte* key, nuint key_len, z_owned_string_t* out_value_string);

        /// <summary>
        ///  Inserts a JSON-serialized `value` at the `key` position of the configuration.
        ///
        ///  Returns 0 if successful, a negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_insert_json5", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_insert_json5(z_loaned_config_t* @this, byte* key, byte* value);

        /// <summary>
        ///  Inserts a JSON-serialized `value` at the `key` position of the configuration.
        ///
        ///  Returns 0 if successful, a negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_insert_json5_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_insert_json5_from_substr(z_loaned_config_t* @this, byte* key, nuint key_len, byte* value, nuint value_len);

        /// <summary>
        ///  Frees `config`, and resets it to its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_config_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_config_drop(z_moved_config_t* this_);

        /// <summary>
        ///  Returns ``true`` if config is valid, ``false`` if it is in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_config_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_config_check(z_owned_config_t* this_);

        /// <summary>
        ///  Reads a configuration from a JSON-serialized string, such as '{mode:"client",connect:{endpoints:["tcp/127.0.0.1:7447"]}}'.
        ///
        ///  Returns 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_from_str(z_owned_config_t* @this, byte* s);

        /// <summary>
        ///  Constructs a json string representation of the `config`, such as '{"mode":"client","connect":{"endpoints":["tcp/127.0.0.1:7447"]}}'.
        ///
        ///  Returns 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_to_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_to_string(z_loaned_config_t* config, z_owned_string_t* out_config_string);

        /// <summary>
        ///  Constructs a configuration by parsing a file at `path`. Currently supported format is JSON5, a superset of JSON.
        ///
        ///  Returns 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_from_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_from_file(z_owned_config_t* @this, byte* path);

        /// <summary>
        ///  Constructs a configuration by parsing a file path stored in ZENOH_CONFIG environmental variable.
        ///
        ///  Returns 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_config_from_env", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_config_from_env(z_owned_config_t* @this);

        /// <summary>
        ///  Initializes the zenoh runtime logger, using rust environment settings.
        ///  E.g.: `RUST_LOG=info` will enable logging at info level. Similarly, you can set the variable to `error` or `debug`.
        ///
        ///  Note that if the environment variable is not set, then logging will not be enabled.
        ///  See https://docs.rs/env_logger/latest/env_logger/index.html for accepted filter format.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_try_init_log_from_env", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_try_init_log_from_env();

        /// <summary>
        ///  Initializes the zenoh runtime logger, using rust environment settings or the provided fallback level.
        ///  E.g.: `RUST_LOG=info` will enable logging at info level. Similarly, you can set the variable to `error` or `debug`.
        ///
        ///  Note that if the environment variable is not set, then fallback filter will be used instead.
        ///  See https://docs.rs/env_logger/latest/env_logger/index.html for accepted filter format.
        ///
        ///  @param fallback_filter: The fallback filter if the `RUST_LOG` environment variable is not set.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_init_log_from_env_or", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t zc_init_log_from_env_or(byte* fallback_filter);

        /// <summary>
        ///  Initializes the zenoh runtime logger with custom callback.
        ///
        ///  @param min_severity: Minimum severity level of log message to be be passed to the `callback`.
        ///  Messages with lower severity levels will be ignored.
        ///  @param callback: A closure that will be called with each log message severity level and content.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_init_log_with_callback", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_init_log_with_callback(zc_log_severity_t min_severity, zc_moved_closure_log_t* callback);

        /// <summary>
        ///  Stops all Zenoh tasks and drops all related static variables.
        ///  All Zenoh-related structures should be properly dropped/undeclared PRIOR to this call.
        ///  None of Zenoh functionality can be used after this call.
        ///  Useful to suppress memory leaks messages due to Zenoh static variables (since they are never destroyed due to Rust language design).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_stop_z_runtime", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_stop_z_runtime();

        /// <summary>
        ///  Constructs the default value for `z_put_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_put_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_put_options_default(z_put_options_t* this_);

        /// <summary>
        ///  Publishes data on specified key expression.
        ///
        ///  @param session: The Zenoh session.
        ///  @param key_expr: The key expression to publish to.
        ///  @param payload: The value to put (consumed upon function return).
        ///  @param options: The put options (all owned values will be consumed upon function return).
        ///
        ///  @return 0 in case of success, negative error values in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_put", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_put(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_moved_bytes_t* payload, z_put_options_t* options);

        /// <summary>
        ///  Constructs the default value for `z_delete_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_delete_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_delete_options_default(z_delete_options_t* this_);

        /// <summary>
        ///  Sends request to delete data on specified key expression (used when working with &lt;a href="https://zenoh.io/docs/manual/abstractions/#storage"&gt; Zenoh storages &lt;/a&gt;).
        ///
        ///  @param session: The zenoh session.
        ///  @param key_expr: The key expression to delete.
        ///  @param options: The delete options.
        ///
        ///  @return 0 in case of success, negative values in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_delete", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_delete(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_delete_options_t* options);

        /// <summary>
        ///  @brief Constructs a serializer with empty payload.
        ///  @param this_: An uninitialized memory location where serializer is to be constructed.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_empty(ze_owned_serializer_t* @this);

        /// <summary>
        ///  @brief Drops `this_`, resetting it to gravestone value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_serializer_drop(ze_moved_serializer_t* this_);

        /// <summary>
        ///  @brief Returns ``true`` if `this_` is in a valid state, ``false`` if it is in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_serializer_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_internal_serializer_check(ze_owned_serializer_t* @this);

        /// <summary>
        ///  @brief Borrows serializer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_serializer_t* ze_serializer_loan(ze_owned_serializer_t* @this);

        /// <summary>
        ///  @brief Muatably borrows serializer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_serializer_t* ze_serializer_loan_mut(ze_owned_serializer_t* @this);

        /// <summary>
        ///  @brief Constructs a serializer in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_serializer_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_internal_serializer_null(ze_owned_serializer_t* this_);

        /// <summary>
        ///  @brief Drop serializer and extract underlying `bytes` object it was writing to.
        ///  @param this_: A serializer instance.
        ///  @param bytes: An uninitialized memory location where `bytes` object` will be written to.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_finish", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_serializer_finish(ze_moved_serializer_t* @this, z_owned_bytes_t* bytes);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_uint8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_uint8(z_owned_bytes_t* this_, byte val);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_uint16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_uint16(z_owned_bytes_t* this_, ushort val);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_uint32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_uint32(z_owned_bytes_t* this_, uint val);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_uint64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_uint64(z_owned_bytes_t* this_, ulong val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_int8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_int8(z_owned_bytes_t* this_, sbyte val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_int16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_int16(z_owned_bytes_t* this_, short val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_int32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_int32(z_owned_bytes_t* this_, int val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_int64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_int64(z_owned_bytes_t* this_, long val);

        /// <summary>
        ///  @brief Serializes a float.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_float", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_float(z_owned_bytes_t* this_, float val);

        /// <summary>
        ///  @brief Serializes a double.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_double", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_double(z_owned_bytes_t* this_, double val);

        /// <summary>
        ///  @brief Serializes a bool.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_bool", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_bool(z_owned_bytes_t* this_, [MarshalAs(UnmanagedType.U1)] bool val);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_uint8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_uint8(z_loaned_bytes_t* @this, byte* dst);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_uint16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_uint16(z_loaned_bytes_t* @this, ushort* dst);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_uint32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_uint32(z_loaned_bytes_t* @this, uint* dst);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_uint64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_uint64(z_loaned_bytes_t* @this, ulong* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_int8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_int8(z_loaned_bytes_t* @this, sbyte* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_int16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_int16(z_loaned_bytes_t* @this, short* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_int32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_int32(z_loaned_bytes_t* @this, int* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_int64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_int64(z_loaned_bytes_t* @this, long* dst);

        /// <summary>
        ///  @brief Deserializes into a float.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_float", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_float(z_loaned_bytes_t* @this, float* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_double", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_double(z_loaned_bytes_t* @this, double* dst);

        /// <summary>
        ///  @brief Deserializes into a bool.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_bool", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_bool(z_loaned_bytes_t* @this, bool* dst);

        /// <summary>
        ///  @brief Serializes a slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_slice(z_owned_bytes_t* @this, z_loaned_slice_t* slice);

        /// <summary>
        ///  @brief Serializes a data from buffer by.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param data: A pointer to the buffer containing data.
        ///  @param len: Length of the buffer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_buf(z_owned_bytes_t* @this, byte* data, nuint len);

        /// <summary>
        ///  @brief Deserializes into a slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_slice(z_loaned_bytes_t* @this, z_owned_slice_t* slice);

        /// <summary>
        ///  @brief Serializes a string.
        ///  The string should be a valid UTF-8.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param str: a string to serialize.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_string(z_owned_bytes_t* @this, z_loaned_string_t* str);

        /// <summary>
        ///  @brief Serializes a substring.
        ///  The substring should be a valid UTF-8.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param start: a pointer to the the start of the substring.
        ///  @param len: the length of the substring.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_substr(z_owned_bytes_t* @this, byte* start, nuint len);

        /// <summary>
        ///  @brief Serializes a null-terminated string.
        ///  The string should be a valid UTF-8.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param str: a pointer to the null-terminated string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serialize_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serialize_str(z_owned_bytes_t* @this, byte* str);

        /// <summary>
        ///  @brief Deserializes into a UTF-8 string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserialize_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserialize_string(z_loaned_bytes_t* @this, z_owned_string_t* str);

        /// <summary>
        ///  @brief Gets deserializer for`this_`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_from_bytes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_deserializer_t ze_deserializer_from_bytes(z_loaned_bytes_t* @this);

        /// <summary>
        ///  @brief Checks if deserializer parsed all of its data.
        ///  @return `true` if there is no more data to parse, `false` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_is_done", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_deserializer_is_done(ze_deserializer_t* this_);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_uint8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_uint8(ze_loaned_serializer_t* this_, byte val);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_uint16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_uint16(ze_loaned_serializer_t* this_, ushort val);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_uint32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_uint32(ze_loaned_serializer_t* this_, uint val);

        /// <summary>
        ///  @brief Serializes an unsigned integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_uint64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_uint64(ze_loaned_serializer_t* this_, ulong val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_int8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_int8(ze_loaned_serializer_t* this_, sbyte val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_int16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_int16(ze_loaned_serializer_t* this_, short val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_int32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_int32(ze_loaned_serializer_t* this_, int val);

        /// <summary>
        ///  @brief Serializes a signed integer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_int64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_int64(ze_loaned_serializer_t* this_, long val);

        /// <summary>
        ///  @brief Serializes a float.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_float", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_float(ze_loaned_serializer_t* this_, float val);

        /// <summary>
        ///  @brief Serializes a double.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_double", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_double(ze_loaned_serializer_t* this_, double val);

        /// <summary>
        ///  @brief Serializes a bool.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_bool", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_bool(ze_loaned_serializer_t* this_, [MarshalAs(UnmanagedType.U1)] bool val);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_uint8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_uint8(ze_deserializer_t* @this, byte* dst);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_uint16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_uint16(ze_deserializer_t* @this, ushort* dst);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_uint32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_uint32(ze_deserializer_t* @this, uint* dst);

        /// <summary>
        ///  @brief Deserializes into an unsigned integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_uint64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_uint64(ze_deserializer_t* @this, ulong* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_int8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_int8(ze_deserializer_t* @this, sbyte* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_int16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_int16(ze_deserializer_t* @this, short* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_int32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_int32(ze_deserializer_t* @this, int* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_int64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_int64(ze_deserializer_t* @this, long* dst);

        /// <summary>
        ///  @brief Deserializes into a float.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_float", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_float(ze_deserializer_t* @this, float* dst);

        /// <summary>
        ///  @brief Deserializes into a signed integer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_double", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_double(ze_deserializer_t* @this, double* dst);

        /// <summary>
        ///  @brief Deserializes into a bool.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_bool", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_bool(ze_deserializer_t* @this, bool* dst);

        /// <summary>
        ///  @brief Serializes a slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_slice(ze_loaned_serializer_t* @this, z_loaned_slice_t* slice);

        /// <summary>
        ///  @brief Serializes a data from buffer.
        ///  @param this_: A serializer instance.
        ///  @param data: A pointer to the buffer containing data.
        ///  @param len: Length of the buffer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_buf(ze_loaned_serializer_t* @this, byte* data, nuint len);

        /// <summary>
        ///  @brief Deserializes into a slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_slice(ze_deserializer_t* @this, z_owned_slice_t* slice);

        /// <summary>
        ///  @brief Serializes a string.
        ///  The string should be a valid UTF-8.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_string(ze_loaned_serializer_t* @this, z_loaned_string_t* str);

        /// <summary>
        ///  @brief Serializes a substring of specified length.
        ///  The subsstring should be a valid UTF-8.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_substr(ze_loaned_serializer_t* @this, byte* start, nuint len);

        /// <summary>
        ///  @brief Serializes a null-terminated string.
        ///  The string should be a valid UTF-8.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_str(ze_loaned_serializer_t* @this, byte* str);

        /// <summary>
        ///  @brief Deserializes into a string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_string(ze_deserializer_t* @this, z_owned_string_t* str);

        /// <summary>
        ///  @brief Initiates serialization of a sequence of multiple elements.
        ///  @param this_: A serializer instance.
        ///  @param len: Length of the sequence. Could be read during deserialization using `ze_deserializer_deserialize_sequence_length`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_serializer_serialize_sequence_length", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_serializer_serialize_sequence_length(ze_loaned_serializer_t* @this, nuint len);

        /// <summary>
        ///  @brief Initiates deserialization of a sequence of multiple elements.
        ///  @param this_: A serializer instance.
        ///  @param len:  pointer where the length of the sequence (previously passed via `z_bytes_writer_serialize_sequence_begin`) will be written.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_deserializer_deserialize_sequence_length", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_deserializer_deserialize_sequence_length(ze_deserializer_t* @this, nuint* len);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Constructs the default value for `ze_publication_cache_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_publication_cache_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_publication_cache_options_default(ze_publication_cache_options_t* @this);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Constructs and declares a publication cache.
        ///
        ///  @param session: A Zenoh session.
        ///  @param pub_cache: An uninitialized location in memory where publication cache will be constructed.
        ///  @param key_expr: The key expression to publish to.
        ///  @param options: Additional options for the publication cache.
        ///
        ///  @returns 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_declare_publication_cache", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_declare_publication_cache(z_loaned_session_t* session, ze_owned_publication_cache_t* pub_cache, z_loaned_keyexpr_t* key_expr, ze_publication_cache_options_t* options);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Declares a background publication cache. It will function in background until the corresponding session is closed or dropped.
        ///
        ///  @param session: A Zenoh session.
        ///  @param key_expr: The key expression to publish to.
        ///  @param options: Additional options for the publication cache.
        ///
        ///  @returns 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_declare_background_publication_cache", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_declare_background_publication_cache(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, ze_publication_cache_options_t* options);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Constructs a publication cache in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_publication_cache_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_internal_publication_cache_null(ze_owned_publication_cache_t* this_);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Returns ``true`` if publication cache is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_publication_cache_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_internal_publication_cache_check(ze_owned_publication_cache_t* this_);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Drops publication cache and resets it to its gravestone state.
        ///  This is equivalent to calling `ze_undeclare_publication_cache()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_publication_cache_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_publication_cache_drop(ze_moved_publication_cache_t* @this);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Returns the key expression of the publication cache.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_publication_cache_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* ze_publication_cache_keyexpr(ze_loaned_publication_cache_t* this_);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Borrows publication cache.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_publication_cache_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_publication_cache_t* ze_publication_cache_loan(ze_owned_publication_cache_t* this_);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_publisher.
        ///  @brief Undeclares publication cache.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_undeclare_publication_cache", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_undeclare_publication_cache(ze_moved_publication_cache_t* @this);

        /// <summary>
        ///  Constructs an empty `z_owned_reply_err_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_reply_err_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_reply_err_null(z_owned_reply_err_t* this_);

        /// <summary>
        ///  Returns ``true`` if reply error is in non-default state, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_reply_err_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_reply_err_check(z_owned_reply_err_t* this_);

        /// <summary>
        ///  Returns reply error payload.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_payload", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_reply_err_payload(z_loaned_reply_err_t* this_);

        /// <summary>
        ///  Returns mutable reply error payload.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_payload_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_reply_err_payload_mut(z_loaned_reply_err_t* this_);

        /// <summary>
        ///  Returns reply error encoding.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_encoding", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_reply_err_encoding(z_loaned_reply_err_t* this_);

        /// <summary>
        ///  Borrows reply error.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_reply_err_t* z_reply_err_loan(z_owned_reply_err_t* this_);

        /// <summary>
        ///  Mutably borrows reply error.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_reply_err_t* z_reply_err_loan_mut(z_owned_reply_err_t* this_);

        /// <summary>
        ///  Frees the memory and resets the reply error it to its default value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_reply_err_drop(z_moved_reply_err_t* this_);

        /// <summary>
        ///  Returns ``true`` if reply contains a valid response, ``false`` otherwise (in this case it contains a errror value).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_is_ok", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_reply_is_ok(z_loaned_reply_t* this_);

        /// <summary>
        ///  Yields the contents of the reply by asserting it indicates a success.
        ///
        ///  Returns `NULL` if reply does not contain a sample (i. e. if `z_reply_is_ok` returns ``false``).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_ok", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_sample_t* z_reply_ok(z_loaned_reply_t* this_);

        /// <summary>
        ///  Yields the contents of the reply by asserting it indicates a success.
        ///
        ///  Returns `NULL` if reply does not contain a sample (i. e. if `z_reply_is_ok` returns ``false``).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_ok_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_sample_t* z_reply_ok_mut(z_loaned_reply_t* this_);

        /// <summary>
        ///  Yields the contents of the reply by asserting it indicates a failure.
        ///
        ///  Returns `NULL` if reply does not contain a error  (i. e. if `z_reply_is_ok` returns ``true``).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_reply_err_t* z_reply_err(z_loaned_reply_t* this_);

        /// <summary>
        ///  Yields the contents of the reply by asserting it indicates a failure.
        ///
        ///  Returns `NULL` if reply does not contain a error  (i. e. if `z_reply_is_ok` returns ``true``).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_reply_err_t* z_reply_err_mut(z_loaned_reply_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Gets the id of the zenoh instance that answered this Reply.
        ///  @return `true` if id is present.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_replier_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_reply_replier_id(z_loaned_reply_t* @this, z_id_t* out_id);

        /// <summary>
        ///  Constructs the reply in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_reply_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_reply_null(z_owned_reply_t* this_);

        /// <summary>
        ///  Constructs an owned shallow copy of reply in provided uninitialized memory location.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_reply_clone(z_owned_reply_t* dst, z_loaned_reply_t* this_);

        /// <summary>
        ///  Constructs default `z_get_options_t`
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_get_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_get_options_default(z_get_options_t* this_);

        /// <summary>
        ///  Query data from the matching queryables in the system.
        ///  Replies are provided through a callback function.
        ///
        ///  @param session: The zenoh session.
        ///  @param key_expr: The key expression matching resources to query.
        ///  @param parameters: The query's parameters, similar to a url's query segment.
        ///  @param callback: The callback function that will be called on reception of replies for this query. It will be automatically dropped once all replies are processed.
        ///  @param options: Additional options for the get. All owned fields will be consumed.
        ///
        ///  @return 0 in case of success, a negative error value upon failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_get", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_get(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, byte* parameters, z_moved_closure_reply_t* callback, z_get_options_t* options);

        /// <summary>
        ///  Frees reply, resetting it to its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_reply_drop(z_moved_reply_t* this_);

        /// <summary>
        ///  Returns ``true`` if `reply` is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_reply_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_reply_check(z_owned_reply_t* this_);

        /// <summary>
        ///  Borrows reply.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_reply_t* z_reply_loan(z_owned_reply_t* this_);

        /// <summary>
        ///  Mutably borrows reply.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_reply_t* z_reply_loan_mut(z_owned_reply_t* this_);

        /// <summary>
        ///  Takes ownership of the mutably borrowed reply
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_take_from_loaned", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_reply_take_from_loaned(z_owned_reply_t* dst, z_loaned_reply_t* src);

        /// <summary>
        ///  Creates a default `z_query_consolidation_t` (consolidation mode AUTO).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_consolidation_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_query_consolidation_t z_query_consolidation_default();

        /// <summary>
        ///  Automatic query consolidation strategy selection.
        ///
        ///  A query consolidation strategy will automatically be selected depending the query selector.
        ///  If the selector contains time range properties, no consolidation is performed.
        ///  Otherwise the `z_query_consolidation_latest` strategy is used.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_consolidation_auto", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_query_consolidation_t z_query_consolidation_auto();

        /// <summary>
        ///  Latest consolidation.
        ///
        ///  This strategy optimizes bandwidth on all links in the system but will provide a very poor latency.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_consolidation_latest", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_query_consolidation_t z_query_consolidation_latest();

        /// <summary>
        ///  Monotonic consolidation.
        ///
        ///  This strategy offers the best latency. Replies are directly transmitted to the application when received
        ///  without needing to wait for all replies. This mode does not guarantee that there will be no duplicates.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_consolidation_monotonic", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_query_consolidation_t z_query_consolidation_monotonic();

        /// <summary>
        ///  No consolidation.
        ///
        ///  This strategy is useful when querying timeseries data bases or when using quorums.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_consolidation_none", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_query_consolidation_t z_query_consolidation_none();

        /// <summary>
        ///  Constructs a copy of the reply error message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reply_err_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_reply_err_clone(z_owned_reply_err_t* dst, z_loaned_reply_err_t* @this);

        /// <summary>
        ///  @brief Constructs liveliness token in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_liveliness_token_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_liveliness_token_null(z_owned_liveliness_token_t* this_);

        /// <summary>
        ///  @brief Returns ``true`` if liveliness token is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_liveliness_token_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_liveliness_token_check(z_owned_liveliness_token_t* this_);

        /// <summary>
        ///  @brief Undeclares liveliness token, frees memory and resets it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_token_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_liveliness_token_drop(z_moved_liveliness_token_t* this_);

        /// <summary>
        ///  @brief Constructs default value for `z_liveliness_token_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_token_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_liveliness_token_options_default(z_liveliness_token_options_t* @this);

        /// <summary>
        ///  @brief Borrows token.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_token_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_liveliness_token_t* z_liveliness_token_loan(z_owned_liveliness_token_t* @this);

        /// <summary>
        ///  @brief Constructs and declares a liveliness token on the network.
        ///
        ///  Liveliness token subscribers on an intersecting key expression will receive a PUT sample when connectivity
        ///  is achieved, and a DELETE sample if it's lost.
        ///
        ///  @param session: A Zenos session to declare the liveliness token.
        ///  @param token: An uninitialized memory location where liveliness token will be constructed.
        ///  @param key_expr: A keyexpr to declare a liveliess token for.
        ///  @param _options: Liveliness token declaration properties.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_declare_token", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_liveliness_declare_token(z_loaned_session_t* session, z_owned_liveliness_token_t* token, z_loaned_keyexpr_t* key_expr, z_liveliness_token_options_t* _options);

        /// <summary>
        ///  @brief Destroys a liveliness token, notifying subscribers of its destruction.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_undeclare_token", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_liveliness_undeclare_token(z_moved_liveliness_token_t* @this);

        /// <summary>
        ///  @brief Constucts default value for `z_liveliness_declare_subscriber_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_subscriber_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_liveliness_subscriber_options_default(z_liveliness_subscriber_options_t* @this);

        /// <summary>
        ///  @brief Declares a subscriber on liveliness tokens that intersect `key_expr`.
        ///
        ///  @param session: A Zenoh session.
        ///  @param subscriber: An uninitialized memory location where subscriber will be constructed.
        ///  @param key_expr: The key expression to subscribe to.
        ///  @param callback: The callback function that will be called each time a liveliness token status is changed.
        ///  @param options: The options to be passed to the liveliness subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error values otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_declare_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_liveliness_declare_subscriber(z_loaned_session_t* session, z_owned_subscriber_t* subscriber, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, z_liveliness_subscriber_options_t* options);

        /// <summary>
        ///  @brief Declares a background subscriber on liveliness tokens that intersect `key_expr`. Subscriber callback will be called to process the messages,
        ///  until the corresponding session is closed or dropped.
        ///  @param session: The Zenoh session.
        ///  @param key_expr: The key expression to subscribe to.
        ///  @param callback: The callback function that will be called each time a liveliness token status is changed.
        ///  @param options: The options to be passed to the liveliness subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error values otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_declare_background_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_liveliness_declare_background_subscriber(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, z_liveliness_subscriber_options_t* options);

        /// <summary>
        ///  @brief Constructs default value `z_liveliness_get_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_get_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_liveliness_get_options_default(z_liveliness_get_options_t* @this);

        /// <summary>
        ///  @brief Queries liveliness tokens currently on the network with a key expression intersecting with `key_expr`.
        ///
        ///  @param session: The Zenoh session.
        ///  @param key_expr: The key expression to query liveliness tokens for.
        ///  @param callback: The callback function that will be called for each received reply.
        ///  @param options: Additional options for the liveliness get operation.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_liveliness_get", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_liveliness_get(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_moved_closure_reply_t* callback, z_liveliness_get_options_t* options);

        /// <summary>
        ///  Constructs a querying subscriber in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_querying_subscriber_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_internal_querying_subscriber_null(ze_owned_querying_subscriber_t* @this);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Constructs the default value for `ze_querying_subscriber_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_querying_subscriber_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_querying_subscriber_options_default(ze_querying_subscriber_options_t* @this);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Constructs and declares a querying subscriber for a given key expression.
        ///
        ///  @param session: A Zenoh session.
        ///  @param querying_subscriber: An uninitialized memory location where querying subscriber will be constructed.
        ///  @param key_expr: A key expression to subscribe to.
        ///  @param callback: The callback function that will be called each time a data matching the subscribed expression is received.
        ///  @param options: Additional options for the querying subscriber.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_declare_querying_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_declare_querying_subscriber(z_loaned_session_t* session, ze_owned_querying_subscriber_t* querying_subscriber, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, ze_querying_subscriber_options_t* options);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Declares a background querying subscriber for a given key expression. Subscriber callback will be called to process the messages,
        ///  until the corresponding session is closed or dropped.
        ///
        ///  @param session: A Zenoh session.
        ///  @param key_expr: A key expression to subscribe to.
        ///  @param callback: The callback function that will be called each time a data matching the subscribed expression is received.
        ///  @param options: Additional options for the querying subscriber.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_declare_background_querying_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_declare_background_querying_subscriber(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, ze_querying_subscriber_options_t* options);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Make querying subscriber perform an additional query on a specified selector.
        ///  The queried samples will be merged with the received publications and made available in the subscriber callback.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_querying_subscriber_get", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_querying_subscriber_get(ze_loaned_querying_subscriber_t* @this, z_loaned_keyexpr_t* selector, z_get_options_t* options);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Undeclares querying subscriber callback and resets it to its gravestone state.
        ///  This is equivalent to calling `ze_undeclare_querying_subscriber()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_querying_subscriber_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_querying_subscriber_drop(ze_moved_querying_subscriber_t* this_);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Returns ``true`` if querying subscriber is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_querying_subscriber_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_internal_querying_subscriber_check(ze_owned_querying_subscriber_t* this_);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Borrows querying subscriber.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_querying_subscriber_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_querying_subscriber_t* ze_querying_subscriber_loan(ze_owned_querying_subscriber_t* @this);

        /// <summary>
        ///  @warning This API is deprecated. Please use ze_advanced_subscriber.
        ///  @brief Undeclares the given querying subscriber.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_undeclare_querying_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_undeclare_querying_subscriber(ze_moved_querying_subscriber_t* this_);

        /// <summary>
        ///  Constructs the default value for `z_publisher_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_publisher_options_default(z_publisher_options_t* this_);

        /// <summary>
        ///  Constructs and declares a publisher for the given key expression.
        ///
        ///  Data can be put and deleted with this publisher with the help of the
        ///  `z_publisher_put()` and `z_publisher_delete()` functions.
        ///
        ///  @param session: The Zenoh session.
        ///  @param publisher: An uninitialized location in memory where publisher will be constructed.
        ///  @param key_expr: The key expression to publish.
        ///  @param options: Additional options for the publisher.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_declare_publisher", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_declare_publisher(z_loaned_session_t* session, z_owned_publisher_t* publisher, z_loaned_keyexpr_t* key_expr, z_publisher_options_t* options);

        /// <summary>
        ///  Constructs a publisher in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_publisher_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_publisher_null(z_owned_publisher_t* this_);

        /// <summary>
        ///  Returns ``true`` if publisher is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_publisher_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_publisher_check(z_owned_publisher_t* this_);

        /// <summary>
        ///  Borrows publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_publisher_t* z_publisher_loan(z_owned_publisher_t* this_);

        /// <summary>
        ///  Mutably borrows publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_publisher_t* z_publisher_loan_mut(z_owned_publisher_t* @this);

        /// <summary>
        ///  Constructs the default value for `z_publisher_put_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_put_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_publisher_put_options_default(z_publisher_put_options_t* @this);

        /// <summary>
        ///  Sends a `PUT` message onto the publisher's key expression, transfering the payload ownership.
        ///
        ///
        ///  The payload and all owned options fields are consumed upon function return.
        ///
        ///  @param this_: The publisher.
        ///  @param payload: The data to publish. Will be consumed.
        ///  @param options: The publisher put options. All owned fields will be consumed.
        ///
        ///  @return 0 in case of success, negative error values in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_put", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_publisher_put(z_loaned_publisher_t* @this, z_moved_bytes_t* payload, z_publisher_put_options_t* options);

        /// <summary>
        ///  Constructs the default values for the delete operation via a publisher entity.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_delete_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_publisher_delete_options_default(z_publisher_delete_options_t* @this);

        /// <summary>
        ///  Sends a `DELETE` message onto the publisher's key expression.
        ///
        ///  @return 0 in case of success, negative error code in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_delete", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_publisher_delete(z_loaned_publisher_t* publisher, z_publisher_delete_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the ID of the publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_entity_global_id_t z_publisher_id(z_loaned_publisher_t* publisher);

        /// <summary>
        ///  Returns the key expression of the publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* z_publisher_keyexpr(z_loaned_publisher_t* publisher);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs matching listener, registering a callback for notifying subscribers matching with a given publisher.
        ///
        ///  @param publisher: A publisher to associate with matching listener.
        ///  @param matching_listener: An uninitialized memory location where matching listener will be constructed. The matching listener's callback will be automatically dropped when the publisher is dropped.
        ///  @param callback: A closure that will be called every time the matching status of the publisher changes (If last subscriber disconnects or when the first subscriber connects).
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_declare_matching_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_publisher_declare_matching_listener(z_loaned_publisher_t* publisher, z_owned_matching_listener_t* matching_listener, z_moved_closure_matching_status_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Declares a matching listener, registering a callback for notifying subscribers matching with a given publisher.
        ///  The callback will be run in the background until the corresponding publisher is dropped.
        ///
        ///  @param publisher: A publisher to associate with matching listener.
        ///  @param callback: A closure that will be called every time the matching status of the publisher changes (If last subscriber disconnects or when the first subscriber connects).
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_declare_background_matching_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_publisher_declare_background_matching_listener(z_loaned_publisher_t* publisher, z_moved_closure_matching_status_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Gets publisher matching status - i.e. if there are any subscribers matching its key expression.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case matching_status is not updated).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_get_matching_status", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_publisher_get_matching_status(z_loaned_publisher_t* @this, z_matching_status_t* matching_status);

        /// <summary>
        ///  Frees memory and resets publisher to its gravestone state.
        ///  This is equivalent to calling `z_undeclare_publisher()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_publisher_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_publisher_drop(z_moved_publisher_t* @this);

        /// <summary>
        ///  @brief Undeclares the given publisher.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_undeclare_publisher", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_undeclare_publisher(z_moved_publisher_t* this_);

        /// <summary>
        ///  Frees memory and resets hello message to its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_hello_drop(z_moved_hello_t* this_);

        /// <summary>
        ///  Borrows hello message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_hello_t* z_hello_loan(z_owned_hello_t* this_);

        /// <summary>
        ///  Mutably borrows hello message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_hello_t* z_hello_loan_mut(z_owned_hello_t* this_);

        /// <summary>
        ///  Takes ownership of the mutably borrowed hello
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_take_from_loaned", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_hello_take_from_loaned(z_owned_hello_t* dst, z_loaned_hello_t* src);

        /// <summary>
        ///  Returns ``true`` if `hello message` is valid, ``false`` if it is in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_hello_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_hello_check(z_owned_hello_t* this_);

        /// <summary>
        ///  Constructs hello message in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_hello_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_hello_null(z_owned_hello_t* this_);

        /// <summary>
        ///  Constructs an owned copy of hello message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_hello_clone(z_owned_hello_t* dst, z_loaned_hello_t* this_);

        /// <summary>
        ///  @brief Returns id of Zenoh entity that transmitted hello message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_zid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_id_t z_hello_zid(z_loaned_hello_t* this_);

        /// <summary>
        ///  Returns type of Zenoh entity that transmitted hello message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_whatami", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_whatami_t z_hello_whatami(z_loaned_hello_t* this_);

        /// <summary>
        ///  Constructs an array of non-owned locators (in the form non-null-terminated strings) of Zenoh entity that sent hello message.
        ///
        ///  The lifetime of locator strings is bound to `this_`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_hello_locators", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_hello_locators(z_loaned_hello_t* @this, z_owned_string_array_t* locators_out);

        /// <summary>
        ///  Constructs the default values for the scouting operation.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_scout_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_scout_options_default(z_scout_options_t* this_);

        /// <summary>
        ///  Scout for routers and/or peers.
        ///
        ///  @param config: A set of properties to configure scouting session.
        ///  @param callback: A closure that will be called on each hello message received from discoverd Zenoh entities.
        ///  @param options: A set of scouting options
        ///
        ///  @return 0 if successful, negative error values upon failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_scout", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_scout(z_moved_config_t* config, z_moved_closure_hello_t* callback, z_scout_options_t* options);

        /// <summary>
        ///  Constructs a non-owned non-null-terminated string from the kind of zenoh entity.
        ///
        ///  The string has static storage (i.e. valid until the end of the program).
        ///  @param whatami: A whatami bitmask of zenoh entity kind.
        ///  @param str_out: An uninitialized memory location where strring will be constructed.
        ///
        ///  @return 0 if successful, negative error values if whatami contains an invalid bitmask.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_whatami_to_view_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_whatami_to_view_string(z_whatami_t whatami, z_view_string_t* str_out);

        /// <summary>
        ///  @brief Formats the `z_id_t` into 16-digit hex string (LSB-first order)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_id_to_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_id_to_string(z_id_t* zid, z_owned_string_t* dst);

        /// <summary>
        ///  @brief Returns the session's Zenoh ID.
        ///
        ///  Unless the `session` is invalid, that ID is guaranteed to be non-zero.
        ///  In other words, this function returning an array of 16 zeros means you failed
        ///  to pass it a valid session.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_info_zid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_id_t z_info_zid(z_loaned_session_t* session);

        /// <summary>
        ///  @brief Fetches the Zenoh IDs of all connected peers.
        ///
        ///  `callback` will be called once for each ID, is guaranteed to never be called concurrently,
        ///  and is guaranteed to be dropped before this function exits.
        ///
        ///  Retuns 0 on success, negative values on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_info_peers_zid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_info_peers_zid(z_loaned_session_t* session, z_moved_closure_zid_t* callback);

        /// <summary>
        ///  @brief Fetches the Zenoh IDs of all connected routers.
        ///
        ///  `callback` will be called once for each ID, is guaranteed to never be called concurrently,
        ///  and is guaranteed to be dropped before this function exits.
        ///
        ///  Retuns 0 on success, negative values on failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_info_routers_zid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_info_routers_zid(z_loaned_session_t* session, z_moved_closure_zid_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `ze_advanced_subscriber_history_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_history_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_subscriber_history_options_default(ze_advanced_subscriber_history_options_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `ze_advanced_subscriber_last_sample_miss_detection_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_last_sample_miss_detection_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_subscriber_last_sample_miss_detection_options_default(ze_advanced_subscriber_last_sample_miss_detection_options_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `ze_advanced_subscriber_recovery_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_recovery_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_subscriber_recovery_options_default(ze_advanced_subscriber_recovery_options_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `ze_advanced_subscriber_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_subscriber_options_default(ze_advanced_subscriber_options_t* @this);

        /// <summary>
        ///  Constructs a subscriber in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_advanced_subscriber_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_internal_advanced_subscriber_null(ze_owned_advanced_subscriber_t* this_);

        /// <summary>
        ///  Borrows subscriber.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_advanced_subscriber_t* ze_advanced_subscriber_loan(ze_owned_advanced_subscriber_t* this_);

        /// <summary>
        ///  Undeclares advanced subscriber callback and resets it to its gravestone state.
        ///  This is equivalent to calling `ze_undeclare_advanced_subscriber()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_subscriber_drop(ze_moved_advanced_subscriber_t* this_);

        /// <summary>
        ///  Returns ``true`` if advanced subscriber is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_advanced_subscriber_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_internal_advanced_subscriber_check(ze_owned_advanced_subscriber_t* this_);

        /// <summary>
        ///  Constructs and declares an advanced subscriber for a given key expression. Dropping subscriber undeclares its callback.
        ///
        ///  @param session: The zenoh session.
        ///  @param subscriber: An uninitialized location in memory, where advanced subscriber will be constructed.
        ///  @param key_expr: The key expression to subscribe.
        ///  @param callback: The callback function that will be called each time a data matching the subscribed expression is received.
        ///  @param options: The options to be passed to the subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case subscriber will be in its gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_declare_advanced_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_declare_advanced_subscriber(z_loaned_session_t* session, ze_owned_advanced_subscriber_t* subscriber, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, ze_advanced_subscriber_options_t* options);

        /// <summary>
        ///  Constructs and declares a background advanced subscriber. Subscriber callback will be called to process the messages,
        ///  until the corresponding session is closed or dropped.
        ///
        ///  @param session: The zenoh session.
        ///  @param key_expr: The key expression to subscribe.
        ///  @param callback: The callback function that will be called each time a data matching the subscribed expression is received.
        ///  @param options: The options to be passed to the subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_declare_background_advanced_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_declare_background_advanced_subscriber(z_loaned_session_t* session, z_loaned_keyexpr_t* key_expr, z_moved_closure_sample_t* callback, ze_advanced_subscriber_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Undeclares the advanced subscriber.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_undeclare_advanced_subscriber", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_undeclare_advanced_subscriber(ze_moved_advanced_subscriber_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs an empty sample miss listener.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_sample_miss_listener_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_internal_sample_miss_listener_null(ze_owned_sample_miss_listener_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Checks the sample_miss listener is for the gravestone state
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_sample_miss_listener_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_internal_sample_miss_listener_check(ze_owned_sample_miss_listener_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Undeclares the given sample miss listener, droping and invalidating it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_sample_miss_listener_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_sample_miss_listener_drop(ze_moved_sample_miss_listener_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Undeclares the given sample miss listener, droping and invalidating it.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_undeclare_sample_miss_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_undeclare_sample_miss_listener(ze_moved_sample_miss_listener_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs sample miss listener, registering a callback for notifying subscriber about missed samples.
        ///
        ///  @param subscriber: A subscriber to associate with sample miss listener.
        ///  @param sample_miss_listener: An uninitialized memory location where sample miss listener will be constructed. The sample miss listener's callback will be automatically dropped when the subscriber is dropped.
        ///  @param callback: A closure that will be called every time the sample miss is detected.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_declare_sample_miss_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_subscriber_declare_sample_miss_listener(ze_loaned_advanced_subscriber_t* subscriber, ze_owned_sample_miss_listener_t* sample_miss_listener, ze_moved_closure_miss_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Declares a sample miss listener, registering a callback for notifying subscriber about missed samples.
        ///  The callback will be run in the background until the corresponding subscriber is dropped.
        ///
        ///  @param subscriber: A subscriber to associate with sample miss listener.
        ///  @param callback: A closure that will be called every time the sample miss is detected.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_declare_background_sample_miss_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_subscriber_declare_background_sample_miss_listener(ze_loaned_advanced_subscriber_t* subscriber, ze_moved_closure_miss_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Declares a liveliness token listener for matching publishers detection. Only advanced publishers, enabling publisher detection can be detected.
        ///
        ///  @param subscriber: The advanced subscriber instance.
        ///  @param liveliness_subscriber: An uninitialized memory location where liveliness subscriber will be constructed.
        ///  @param callback: The callback function that will be called each time a liveliness token status is changed.
        ///  @param options: The options to be passed to the liveliness subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error values otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_detect_publishers", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_subscriber_detect_publishers(ze_loaned_advanced_subscriber_t* subscriber, z_owned_subscriber_t* liveliness_subscriber, z_moved_closure_sample_t* callback, z_liveliness_subscriber_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Declares a background subscriber on liveliness tokens of matching publishers. Subscriber callback will be called to process the messages,
        ///  until the corresponding session is closed or dropped. Only advanced publishers. enabling publisher detection can be detected.
        ///  @param subscriber: The advanced subscriber instance.
        ///  @param callback: The callback function that will be called each time a liveliness token status is changed.
        ///  @param options: The options to be passed to the liveliness subscriber declaration.
        ///
        ///  @return 0 in case of success, negative error values otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_detect_publishers_background", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_subscriber_detect_publishers_background(ze_loaned_advanced_subscriber_t* subscriber, z_moved_closure_sample_t* callback, z_liveliness_subscriber_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Returns the key expression of the advanced subscriber.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* ze_advanced_subscriber_keyexpr(ze_loaned_advanced_subscriber_t* subscriber);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the ID of the advanced subscriber.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_subscriber_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_entity_global_id_t ze_advanced_subscriber_id(ze_loaned_advanced_subscriber_t* subscriber);

        /// <summary>
        ///  The gravestone value for `z_owned_bytes_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_bytes_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_bytes_null(z_owned_bytes_t* @this);

        /// <summary>
        ///  Constructs an empty instance of `z_owned_bytes_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_empty(z_owned_bytes_t* @this);

        /// <summary>
        ///  Drops `this_`, resetting it to gravestone value. If there are any shallow copies
        ///  created by `z_bytes_clone()`, they would still stay valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_drop(z_moved_bytes_t* this_);

        /// <summary>
        ///  Returns ``true`` if `this_` is in a valid state, ``false`` if it is in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_bytes_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_bytes_check(z_owned_bytes_t* @this);

        /// <summary>
        ///  Borrows data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_bytes_loan(z_owned_bytes_t* @this);

        /// <summary>
        ///  Muatably borrows data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_bytes_loan_mut(z_owned_bytes_t* @this);

        /// <summary>
        ///  Returns ``true`` if `this_` is empty, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_bytes_is_empty(z_loaned_bytes_t* @this);

        /// <summary>
        ///  Constructs an owned shallow copy of data in provided uninitialized memory location.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_clone(z_owned_bytes_t* dst, z_loaned_bytes_t* @this);

        /// <summary>
        ///  Returns total number of bytes in the payload.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_bytes_len(z_loaned_bytes_t* @this);

        /// <summary>
        ///  Converts data into an owned non-null-terminated string.
        ///
        ///  @param this_: Data to convert.
        ///  @param dst: An uninitialized memory location where to construct a string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_to_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_to_string(z_loaned_bytes_t* @this, z_owned_string_t* dst);

        /// <summary>
        ///  Converts data into an owned slice.
        ///
        ///  @param this_: Data to convert.
        ///  @param dst: An uninitialized memory location where to construct a slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_to_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_to_slice(z_loaned_bytes_t* @this, z_owned_slice_t* dst);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Converts data into an owned SHM buffer by copying it's shared reference.
        ///
        ///  @param this_: Data to convert.
        ///  @param dst: An uninitialized memory location where to construct an SHM buffer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_to_owned_shm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_to_owned_shm(z_loaned_bytes_t* @this, z_owned_shm_t* dst);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Converts data into a loaned SHM buffer.
        ///
        ///  @param this_: Data to convert.
        ///  @param dst: An uninitialized memory location where to construct an SHM buffer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_as_loaned_shm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_as_loaned_shm(z_loaned_bytes_t* @this, z_loaned_shm_t** dst);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Converts data into a mutably loaned SHM buffer.
        ///
        ///  @param this_: Data to convert.
        ///  @param dst: An uninitialized memory location where to construct an SHM buffer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_as_mut_loaned_shm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_as_mut_loaned_shm(z_loaned_bytes_t* @this, z_loaned_shm_t** dst);

        /// <summary>
        ///  Converts a slice into `z_owned_bytes_t`.
        ///  The slice is consumed upon function return.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_from_slice(z_owned_bytes_t* @this, z_moved_slice_t* slice);

        /// <summary>
        ///  Converts a slice into `z_owned_bytes_t` by copying.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_copy_from_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_copy_from_slice(z_owned_bytes_t* @this, z_loaned_slice_t* slice);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_bytes_from_buf_deleter_delegate(void* data, void* context);

        /// <summary>
        ///  Converts buffer into `z_owned_bytes_t`.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param data: A pointer to the buffer containing data. `this_` will take ownership of the buffer.
        ///  @param len: Length of the buffer.
        ///  @param deleter: A thread-safe function, that will be called on `data` when `this_` is dropped. Can be `NULL` if `data` is located in static memory and does not require a drop.
        ///  @param context: An optional context to be passed to `deleter`.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_from_buf(z_owned_bytes_t* @this, byte* data, nuint len, z_bytes_from_buf_deleter_delegate deleter, void* context);

        /// <summary>
        ///  Converts a statically allocated constant buffer into `z_owned_bytes_t`.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param data: A pointer to the statically allocated constant data.
        ///  @param len: A length of the buffer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_static_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_from_static_buf(z_owned_bytes_t* @this, byte* data, nuint len);

        /// <summary>
        ///  Converts a data from buffer into `z_owned_bytes_t` by copying.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param data: A pointer to the buffer containing data.
        ///  @param len: Length of the buffer.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_copy_from_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_copy_from_buf(z_owned_bytes_t* @this, byte* data, nuint len);

        /// <summary>
        ///  Converts a string into `z_owned_bytes_t`.
        ///  The string is consumed upon function return.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_from_string(z_owned_bytes_t* @this, z_moved_string_t* s);

        /// <summary>
        ///  Converts a string into `z_owned_bytes_t` by copying.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_copy_from_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_copy_from_string(z_owned_bytes_t* @this, z_loaned_string_t* str);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_bytes_from_str_deleter_delegate(void* data, void* context);

        /// <summary>
        ///  Converts a null-terminated string into `z_owned_bytes_t`.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param str: a pointer to the string. `this_` will take ownership of the string.
        ///  @param deleter: A thread-safe function, that will be called on `str` when `this_` is dropped. Can be `NULL` if `str` is located in static memory and does not require a drop.
        ///  @param context: An optional context to be passed to `deleter`.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_from_str(z_owned_bytes_t* @this, byte* str, z_bytes_from_str_deleter_delegate deleter, void* context);

        /// <summary>
        ///  Converts a statically allocated constant null-terminated string into `z_owned_bytes_t` by aliasing.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param str: a pointer to the statically allocated constant string.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_static_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_from_static_str(z_owned_bytes_t* @this, byte* str);

        /// <summary>
        ///  Converts a null-terminated string into `z_owned_bytes_t` by copying.
        ///  @param this_: An uninitialized location in memory where `z_owned_bytes_t` is to be constructed.
        ///  @param str: a pointer to the null-terminated string.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_copy_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_copy_from_str(z_owned_bytes_t* @this, byte* str);

        /// <summary>
        ///  Returns an iterator on raw bytes slices contained in the `z_loaned_bytes_t`.
        ///
        ///  Zenoh may store data in non-contiguous regions of memory, this iterator
        ///  then allows to access raw data directly without any attempt of deserializing it.
        ///  Please note that no guarantee is provided on the internal memory layout.
        ///  The only provided guarantee is on the bytes order that is preserved.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_get_slice_iterator", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_bytes_slice_iterator_t z_bytes_get_slice_iterator(z_loaned_bytes_t* @this);

        /// <summary>
        ///  Gets next slice.
        ///  @param this_: Slice iterator.
        ///  @param slice: An unitialized memory location where the view for the next slice will be constructed.
        ///  @return `false` if there are no more slices (in this case slice will stay unchanged), `true` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_slice_iterator_next", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_bytes_slice_iterator_next(z_bytes_slice_iterator_t* @this, z_view_slice_t* slice);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Attempts to get a contiguous view to the underlying bytes.
        ///  This is only possible if data is not fragmented, otherwise the function will fail.
        ///  In case of fragmented data, consider using `z_bytes_get_slice_iterator()`.
        ///
        ///  @param this_: An instance of Zenoh data.
        ///  @param view: An uninitialized memory location where a contiguous view on data will be constructed.
        ///  @return  0 upon success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_get_contiguous_view", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_get_contiguous_view(z_loaned_bytes_t* @this, z_view_slice_t* view);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Converts from an immutable SHM buffer consuming it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_shm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_from_shm(z_owned_bytes_t* @this, z_moved_shm_t* shm);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Converts a mutable SHM buffer consuming it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_from_shm_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_from_shm_mut(z_owned_bytes_t* @this, z_moved_shm_mut_t* shm);

        /// <summary>
        ///  Returns a reader for the data.
        ///
        ///  The `data` should outlive the reader.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_get_reader", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_bytes_reader_t z_bytes_get_reader(z_loaned_bytes_t* data);

        /// <summary>
        ///  Reads data into specified destination.
        ///
        ///  @param this_: Data reader to read from.
        ///  @param dst: Buffer where the read data is written.
        ///  @param len: Maximum number of bytes to read.
        ///  @return number of bytes read. If return value is smaller than `len`, it means that  theend of the data was reached.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_reader_read", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_bytes_reader_read(z_bytes_reader_t* @this, byte* dst, nuint len);

        /// <summary>
        ///  Sets the `reader` position indicator for the payload to the value pointed to by offset.
        ///  The new position is exactly `offset` bytes measured from the beginning of the payload if origin is `SEEK_SET`,
        ///  from the current reader position if origin is `SEEK_CUR`, and from the end of the payload if origin is `SEEK_END`.
        ///  @return 0 upon success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_reader_seek", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_reader_seek(z_bytes_reader_t* @this, long offset, int origin);

        /// <summary>
        ///  Gets the read position indicator.
        ///  @return read position indicator on success or -1L if failure occurs.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_reader_tell", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern long z_bytes_reader_tell(z_bytes_reader_t* this_);

        /// <summary>
        ///  Gets the number of bytes that can still be read.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_reader_remaining", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_bytes_reader_remaining(z_bytes_reader_t* this_);

        /// <summary>
        ///  @brief Constructs a data writer with empty payload.
        ///  @param this_: An uninitialized memory location where writer is to be constructed.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_writer_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_writer_empty(z_owned_bytes_writer_t* @this);

        /// <summary>
        ///  Drops `this_`, resetting it to gravestone value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_writer_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_writer_drop(z_moved_bytes_writer_t* this_);

        /// <summary>
        ///  Returns ``true`` if `this_` is in a valid state, ``false`` if it is in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_bytes_writer_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_bytes_writer_check(z_owned_bytes_writer_t* @this);

        /// <summary>
        ///  Borrows writer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_writer_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_writer_t* z_bytes_writer_loan(z_owned_bytes_writer_t* @this);

        /// <summary>
        ///  Muatably borrows writer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_writer_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_writer_t* z_bytes_writer_loan_mut(z_owned_bytes_writer_t* @this);

        /// <summary>
        ///  Constructs a writer in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_bytes_writer_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_bytes_writer_null(z_owned_bytes_writer_t* this_);

        /// <summary>
        ///  @brief Drop writer and extract underlying `bytes` object it was writing to.
        ///  @param this_: A writer instance.
        ///  @param bytes: An uninitialized memory location where `bytes` object` will be written to.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_writer_finish", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_bytes_writer_finish(z_moved_bytes_writer_t* @this, z_owned_bytes_t* bytes);

        /// <summary>
        ///  Writes `len` bytes from `src` into underlying data.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_writer_write_all", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_writer_write_all(z_loaned_bytes_writer_t* @this, byte* src, nuint len);

        /// <summary>
        ///  Appends bytes.     
        ///  This allows to compose a serialized data out of multiple `z_owned_bytes_t` that may point to different memory regions.
        ///  Said in other terms, it allows to create a linear view on different memory regions without copy.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_bytes_writer_append", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_bytes_writer_append(z_loaned_bytes_writer_t* @this, z_moved_bytes_t* bytes);

        /// <summary>
        ///  Constructs an owned key expression in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_keyexpr_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_keyexpr_null(z_owned_keyexpr_t* this_);

        /// <summary>
        ///  Constructs a view key expression in empty state
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_view_keyexpr_empty(z_view_keyexpr_t* this_);

        /// <summary>
        ///  Constructs a `z_owned_keyexpr_t` from a string, copying the passed string.
        ///  @return 0 in case of success, negative error code in case of failure (for example if `expr` is not a valid key expression or if it is
        ///  not in canon form.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_from_str(z_owned_keyexpr_t* @this, byte* expr);

        /// <summary>
        ///  Constructs `z_owned_keyexpr_t` from a string, copying the passed string. The copied string is canonized.
        ///  @return 0 in case of success, negative error code in case of failure (for example if expr is not a valid key expression
        ///  even despite canonization).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_from_str_autocanonize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_from_str_autocanonize(z_owned_keyexpr_t* @this, byte* expr);

        /// <summary>
        ///  Borrows `z_owned_keyexpr_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* z_keyexpr_loan(z_owned_keyexpr_t* this_);

        /// <summary>
        ///  Borrows `z_view_keyexpr_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* z_view_keyexpr_loan(z_view_keyexpr_t* this_);

        /// <summary>
        ///  Frees key expression and resets it to its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_keyexpr_drop(z_moved_keyexpr_t* this_);

        /// <summary>
        ///  Returns ``true`` if `keyexpr` is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_keyexpr_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_keyexpr_check(z_owned_keyexpr_t* this_);

        /// <summary>
        ///  Returns ``true`` if `keyexpr` is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_view_keyexpr_is_empty(z_view_keyexpr_t* this_);

        /// <summary>
        ///  Returns 0 if the passed string is a valid (and canon) key expression.
        ///  Otherwise returns negative error value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_is_canon", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_is_canon(byte* start, nuint len);

        /// <summary>
        ///  Canonizes the passed string in place, possibly shortening it by placing a new null-terminator.
        ///  May SEGFAULT if `start` is NULL or lies in read-only memory (as values initialized with string litterals do).
        ///
        ///  @return 0 upon success, negative error values upon failure (if the passed string was an invalid
        ///  key expression for reasons other than a non-canon form).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_canonize_null_terminated", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_canonize_null_terminated(byte* start);

        /// <summary>
        ///  Canonizes the passed string in place, possibly shortening it by modifying `len`.
        ///
        ///  May SEGFAULT if `start` is NULL or lies in read-only memory (as values initialized with string litterals do).
        ///
        ///  @return 0 upon success, negative error values upon failure (if the passed string was an invalid
        ///  key expression for reasons other than a non-canon form).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_canonize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_canonize(byte* start, nuint* len);

        /// <summary>
        ///  Constructs a `z_view_keyexpr_t` by aliasing a substring.
        ///  `expr` must outlive the constucted key expression.
        ///
        ///  @param this_: An uninitialized location in memory where key expression will be constructed.
        ///  @param expr: A buffer with length &gt;= `len`.
        ///  @param len: Number of characters from `expr` to consider.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_view_keyexpr_from_substr(z_view_keyexpr_t* @this, byte* expr, nuint len);

        /// <summary>
        ///  Constructs a `z_owned_keyexpr_t` by copying a substring.
        ///
        ///  @param this_: An uninitialized location in memory where key expression will be constructed.
        ///  @param expr: A buffer with length &gt;= `len`.
        ///  @param len: Number of characters from `expr` to consider.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_from_substr(z_owned_keyexpr_t* @this, byte* expr, nuint len);

        /// <summary>
        ///  Constructs a `z_view_keyexpr_t` by aliasing a substring.
        ///  May SEGFAULT if `start` is NULL or lies in read-only memory (as values initialized with string litterals do).
        ///  `expr` must outlive the constucted key expression.
        ///
        ///  @param this_: An uninitialized location in memory where key expression will be constructed
        ///  @param start: A buffer of with length &gt;= `len`.
        ///  @param len: Number of characters from `expr` to consider. Will be modified to be equal to canonized key expression length.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_from_substr_autocanonize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_view_keyexpr_from_substr_autocanonize(z_view_keyexpr_t* @this, byte* start, nuint* len);

        /// <summary>
        ///  Constructs a `z_keyexpr_t` by copying a substring.
        ///
        ///  @param this_: An uninitialized location in memory where key expression will be constructed.
        ///  @param start: A buffer of with length &gt;= `len`.
        ///  @param len: Number of characters from `expr` to consider. Will be modified to be equal to canonized key expression length.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_from_substr_autocanonize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_from_substr_autocanonize(z_owned_keyexpr_t* @this, byte* start, nuint* len);

        /// <summary>
        ///  Constructs a `z_view_keyexpr_t` by aliasing a string.
        ///  @return 0 in case of success, negative error code in case of failure (for example if expr is not a valid key expression or if it is
        ///  not in canon form.
        ///  `expr` must outlive the constucted key expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_view_keyexpr_from_str(z_view_keyexpr_t* @this, byte* expr);

        /// <summary>
        ///  Constructs a `z_view_keyexpr_t` by aliasing a string.
        ///  The string is canonized in-place before being passed to keyexpr, possibly shortening it by modifying `len`.
        ///  May SEGFAULT if `expr` is NULL or lies in read-only memory (as values initialized with string litterals do).
        ///  `expr` must outlive the constucted key expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_from_str_autocanonize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_view_keyexpr_from_str_autocanonize(z_view_keyexpr_t* @this, byte* expr);

        /// <summary>
        ///  Constructs a `z_view_keyexpr_t` by aliasing a substring without checking any of `z_view_keyexpr_t`'s assertions:
        ///
        ///  - `start` MUST be valid UTF8.
        ///  - `start` MUST follow the Key Expression specification, i.e.:
        ///   - MUST NOT contain ``//``, MUST NOT start nor end with ``/``, MUST NOT contain any of the characters ``?#$``.
        ///   - any instance of ``**`` may only be lead or followed by ``/``.
        ///   - the key expression must have canon form.
        ///
        ///  `start` must outlive constructed key expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_from_substr_unchecked", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_view_keyexpr_from_substr_unchecked(z_view_keyexpr_t* @this, byte* start, nuint len);

        /// <summary>
        ///  Constructs a `z_view_keyexpr_t` by aliasing a string without checking any of `z_view_keyexpr_t`'s assertions:
        ///
        ///   - `s` MUST be valid UTF8.
        ///   - `s` MUST follow the Key Expression specification, i.e.:
        ///    - MUST NOT contain `//`, MUST NOT start nor end with `/`, MUST NOT contain any of the characters `?#$`.
        ///    - any instance of `**` may only be lead or followed by `/`.
        ///    - the key expression must have canon form.
        ///
        ///  `s` must outlive constructed key expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_keyexpr_from_str_unchecked", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_view_keyexpr_from_str_unchecked(z_view_keyexpr_t* @this, byte* s);

        /// <summary>
        ///  Constructs a non-owned non-null-terminated string from key expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_as_view_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_keyexpr_as_view_string(z_loaned_keyexpr_t* @this, z_view_string_t* out_string);

        /// <summary>
        ///  Constructs and declares a key expression on the network. This reduces key key expression to a numerical id,
        ///  which allows to save the bandwitdth, when passing key expression between Zenoh entities.
        ///
        ///  @param session: Session on which to declare key expression.
        ///  @param declared_key_expr: An uninitialized location in memory where key expression will be constructed.
        ///  @param key_expr: Key expression to declare on network.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_declare_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_declare_keyexpr(z_loaned_session_t* session, z_owned_keyexpr_t* declared_key_expr, z_loaned_keyexpr_t* key_expr);

        /// <summary>
        ///  Undeclares the key expression generated by a call to `z_declare_keyexpr()`.
        ///  The key expression is consumed.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_undeclare_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_undeclare_keyexpr(z_loaned_session_t* session, z_moved_keyexpr_t* key_expr);

        /// <summary>
        ///  Returns ``true`` if both ``left`` and ``right`` are equal, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_equals", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_keyexpr_equals(z_loaned_keyexpr_t* left, z_loaned_keyexpr_t* right);

        /// <summary>
        ///  Returns ``true`` if the keyexprs intersect, i.e. there exists at least one key which is contained in both of the
        ///  sets defined by ``left`` and ``right``, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_intersects", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_keyexpr_intersects(z_loaned_keyexpr_t* left, z_loaned_keyexpr_t* right);

        /// <summary>
        ///  Returns ``true`` if ``left`` includes ``right``, i.e. the set defined by ``left`` contains every key belonging to the set
        ///  defined by ``right``, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_includes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_keyexpr_includes(z_loaned_keyexpr_t* left, z_loaned_keyexpr_t* right);

        /// <summary>
        ///  Constructs key expression by concatenation of key expression in `left` with a string in `right`.
        ///  Returns 0 in case of success, negative error code otherwise.
        ///
        ///  You should probably prefer `z_keyexpr_join` as Zenoh may then take advantage of the hierachical separation it inserts.
        ///  To avoid odd behaviors, concatenating a key expression starting with `*` to one ending with `*` is forbidden by this operation,
        ///  as this would extremely likely cause bugs.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_concat", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_concat(z_owned_keyexpr_t* @this, z_loaned_keyexpr_t* left, byte* right_start, nuint right_len);

        /// <summary>
        ///  Constructs key expression by performing path-joining (automatically inserting '/' in-between) of `left` with `right`.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_join", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_keyexpr_join(z_owned_keyexpr_t* @this, z_loaned_keyexpr_t* left, z_loaned_keyexpr_t* right);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the relation between `left` and `right` from `left`'s point of view.
        ///
        ///  @note This is slower than `z_keyexpr_intersects` and `keyexpr_includes`, so you should favor these methods for most applications.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_relation_to", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_keyexpr_intersection_level_t z_keyexpr_relation_to(z_loaned_keyexpr_t* left, z_loaned_keyexpr_t* right);

        /// <summary>
        ///  Constructs a copy of the key expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_keyexpr_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_keyexpr_clone(z_owned_keyexpr_t* dst, z_loaned_keyexpr_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `z_querier_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_querier_options_default(z_querier_options_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs and declares a querier on the given key expression.
        ///
        ///  The queries can be send with the help of the `z_querier_get()` function.
        ///
        ///  @param session: The Zenoh session.
        ///  @param querier: An uninitialized location in memory where querier will be constructed.
        ///  @param key_expr: The key expression to send queries on.
        ///  @param options: Additional options for the querier.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_declare_querier", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_declare_querier(z_loaned_session_t* session, z_owned_querier_t* querier, z_loaned_keyexpr_t* key_expr, z_querier_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs a querier in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_querier_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_querier_null(z_owned_querier_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns ``true`` if querier is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_querier_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_querier_check(z_owned_querier_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Borrows querier.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_querier_t* z_querier_loan(z_owned_querier_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Mutably borrows querier.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_querier_t* z_querier_loan_mut(z_owned_querier_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `z_querier_get_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_get_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_querier_get_options_default(z_querier_get_options_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Query data from the matching queryables in the system.
        ///  Replies are provided through a callback function.
        ///
        ///  @param querier: The querier to make query from.
        ///  @param parameters: The query's parameters, similar to a url's query segment.
        ///  @param callback: The callback function that will be called on reception of replies for this query. It will be automatically dropped once all replies are processed.
        ///  @param options: Additional options for the get. All owned fields will be consumed.
        ///
        ///  @return 0 in case of success, a negative error value upon failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_get", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_querier_get(z_loaned_querier_t* querier, byte* parameters, z_moved_closure_reply_t* callback, z_querier_get_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the ID of the querier.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_entity_global_id_t z_querier_id(z_loaned_querier_t* querier);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the key expression of the querier.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* z_querier_keyexpr(z_loaned_querier_t* querier);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs matching listener, registering a callback for notifying queryables matching with a given querier's key expression and target.
        ///
        ///  @param querier: A querier to associate with matching listener.
        ///  @param matching_listener: An uninitialized memory location where matching listener will be constructed. The matching listener's callback will be automatically dropped when the querier is dropped.
        ///  @param callback: A closure that will be called every time the matching status of the querier changes (If last queryable disconnects or when the first queryable connects).
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_declare_matching_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_querier_declare_matching_listener(z_loaned_querier_t* querier, z_owned_matching_listener_t* matching_listener, z_moved_closure_matching_status_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Declares a matching listener, registering a callback for notifying queryables matching the given querier key expression and target.
        ///  The callback will be run in the background until the corresponding querier is dropped.
        ///
        ///  @param querier: A querier to associate with matching listener.
        ///  @param callback: A closure that will be called every time the matching status of the querier changes (If last queryable disconnects or when the first queryable connects).
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_declare_background_matching_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_querier_declare_background_matching_listener(z_loaned_querier_t* querier, z_moved_closure_matching_status_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Gets querier matching status - i.e. if there are any queryables matching its key expression and target.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case matching_status is not updated).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_get_matching_status", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_querier_get_matching_status(z_loaned_querier_t* @this, z_matching_status_t* matching_status);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Frees memory and resets querier to its gravestone state.
        ///  This is equivalent to calling `z_undeclare_querier()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_querier_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_querier_drop(z_moved_querier_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Undeclares the given querier.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_undeclare_querier", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_undeclare_querier(z_moved_querier_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `ze_advanced_publisher_cache_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_cache_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_publisher_cache_options_default(ze_advanced_publisher_cache_options_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs the default value for `ze_advanced_publisher_sample_miss_detection_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_sample_miss_detection_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_publisher_sample_miss_detection_options_default(ze_advanced_publisher_sample_miss_detection_options_t* @this);

        /// <summary>
        ///  Constructs the default value for `z_publisher_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_publisher_options_default(ze_advanced_publisher_options_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Constructs and declares an advanced publisher for the given key expression.
        ///
        ///  Data can be put and deleted with this publisher with the help of the
        ///  `ze_advanced_publisher_put()` and `ze_advanced_publisher_delete()` functions.
        ///
        ///  @param session: The Zenoh session.
        ///  @param publisher: An uninitialized location in memory where advanced publisher will be constructed.
        ///  @param key_expr: The key expression to publish to.
        ///  @param options: Additional options for the advanced publisher.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_declare_advanced_publisher", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_declare_advanced_publisher(z_loaned_session_t* session, ze_owned_advanced_publisher_t* publisher, z_loaned_keyexpr_t* key_expr, ze_advanced_publisher_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Constructs an advanced publisher in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_advanced_publisher_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_internal_advanced_publisher_null(ze_owned_advanced_publisher_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Returns ``true`` if advanced publisher is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_advanced_publisher_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_internal_advanced_publisher_check(ze_owned_advanced_publisher_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Borrows advanced publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_advanced_publisher_t* ze_advanced_publisher_loan(ze_owned_advanced_publisher_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Mutably borrows advanced publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_advanced_publisher_t* ze_advanced_publisher_loan_mut(ze_owned_advanced_publisher_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Constructs the default value for `ze_advanced_publisher_put_options_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_put_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_publisher_put_options_default(ze_advanced_publisher_put_options_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Sends a `PUT` message onto the advanced publisher's key expression, transfering the payload ownership.
        ///
        ///  The payload and all owned options fields are consumed upon function return.
        ///
        ///  @param this_: The advanced publisher.
        ///  @param payload: The data to publish. Will be consumed.
        ///  @param options: The advanced publisher put options. All owned fields will be consumed.
        ///
        ///  @return 0 in case of success, negative error values in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_put", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_publisher_put(ze_loaned_advanced_publisher_t* @this, z_moved_bytes_t* payload, ze_advanced_publisher_put_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Constructs the default values for the delete operation via an advanced publisher entity.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_delete_options_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_publisher_delete_options_default(ze_advanced_publisher_delete_options_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Sends a `DELETE` message onto the advanced publisher's key expression.
        ///
        ///  @return 0 in case of success, negative error code in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_delete", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_publisher_delete(ze_loaned_advanced_publisher_t* publisher, ze_advanced_publisher_delete_options_t* options);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the ID of the advanced publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_entity_global_id_t ze_advanced_publisher_id(ze_loaned_advanced_publisher_t* publisher);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Returns the key expression of the publisher.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* ze_advanced_publisher_keyexpr(ze_loaned_advanced_publisher_t* publisher);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs matching listener, registering a callback for notifying subscribers matching with a given advanced publisher.
        ///
        ///  @param publisher: An advanced publisher to associate with matching listener.
        ///  @param matching_listener: An uninitialized memory location where matching listener will be constructed. The matching listener's callback will be automatically dropped when the publisher is dropped.
        ///  @param callback: A closure that will be called every time the matching status of the publisher changes (If last subscriber disconnects or when the first subscriber connects).
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_declare_matching_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_publisher_declare_matching_listener(ze_loaned_advanced_publisher_t* publisher, z_owned_matching_listener_t* matching_listener, z_moved_closure_matching_status_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Declares a matching listener, registering a callback for notifying subscribers matching with a given advanced publisher.
        ///  The callback will be run in the background until the corresponding publisher is dropped.
        ///
        ///  @param publisher: An advanced publisher to associate with matching listener.
        ///  @param callback: A closure that will be called every time the matching status of the publisher changes (If last subscriber disconnects or when the first subscriber connects).
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_declare_background_matching_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_publisher_declare_background_matching_listener(ze_loaned_advanced_publisher_t* publisher, z_moved_closure_matching_status_t* callback);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Gets advanced publisher matching status - i.e. if there are any subscribers matching its key expression.
        ///
        ///  @return 0 in case of success, negative error code otherwise (in this case matching_status is not updated).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_get_matching_status", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_advanced_publisher_get_matching_status(ze_loaned_advanced_publisher_t* @this, z_matching_status_t* matching_status);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  Frees memory and resets advanced_publisher to its gravestone state.
        ///  This is equivalent to calling `z_undeclare_publisher()` and discarding its return value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_advanced_publisher_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_advanced_publisher_drop(ze_moved_advanced_publisher_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Undeclares the given advanced publisher.
        ///
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_undeclare_advanced_publisher", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t ze_undeclare_advanced_publisher(ze_moved_advanced_publisher_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs an empty matching listener.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_matching_listener_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_matching_listener_null(z_owned_matching_listener_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Checks the matching listener is for the gravestone state
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_matching_listener_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_matching_listener_check(z_owned_matching_listener_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Undeclares the given matching listener, droping and invalidating it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_matching_listener_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_matching_listener_drop(z_moved_matching_listener_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Undeclares the given matching listener, droping and invalidating it.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_undeclare_matching_listener", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_undeclare_matching_listener(z_moved_matching_listener_t* @this);

        /// <summary>
        ///  Constructs an empty view slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_slice_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_view_slice_empty(z_view_slice_t* this_);

        /// <summary>
        ///  Constructs a `len` bytes long view starting at `start`.
        ///
        ///  @return -1 if `start == NULL` and `len &gt; 0` (and creates an empty view slice), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_slice_from_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_view_slice_from_buf(z_view_slice_t* @this, byte* start, nuint len);

        /// <summary>
        ///  Borrows view slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_slice_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_slice_t* z_view_slice_loan(z_view_slice_t* this_);

        /// <summary>
        ///  @return ``true`` if the slice is not empty, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_slice_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_view_slice_is_empty(z_view_slice_t* this_);

        /// <summary>
        ///  Constructs an empty `z_owned_slice_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_slice_empty(z_owned_slice_t* this_);

        /// <summary>
        ///  Constructs an empty `z_owned_slice_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_slice_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_slice_null(z_owned_slice_t* this_);

        /// <summary>
        ///  Frees the memory and invalidates the slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_slice_drop(z_moved_slice_t* this_);

        /// <summary>
        ///  Borrows slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_slice_t* z_slice_loan(z_owned_slice_t* this_);

        /// <summary>
        ///  Constructs an owned copy of a slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_slice_clone(z_owned_slice_t* dst, z_loaned_slice_t* this_);

        /// <summary>
        ///  @return ``true`` if slice is not empty, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_slice_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_slice_check(z_owned_slice_t* this_);

        /// <summary>
        ///  @return the length of the slice.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_slice_len(z_loaned_slice_t* this_);

        /// <summary>
        ///  @return the pointer to the slice data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* z_slice_data(z_loaned_slice_t* this_);

        /// <summary>
        ///  @return ``true`` if slice is empty, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_slice_is_empty(z_loaned_slice_t* this_);

        /// <summary>
        ///  Constructs a slice by copying a `len` bytes long sequence starting at `start`.
        ///
        ///  @return -1 if `start == NULL` and `len &gt; 0` (creating an empty slice), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_copy_from_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_slice_copy_from_buf(z_owned_slice_t* @this, byte* start, nuint len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_slice_from_buf_drop_delegate(void* data, void* context);

        /// <summary>
        ///  Constructs a slice by transferring ownership of `data` to it.
        ///  @param this_: Pointer to an uninitialized memoery location where slice will be constructed.
        ///  @param data: Pointer to the data to be owned by `this_`.
        ///  @param len: Number of bytes in `data`.
        ///  @param drop: A thread-safe delete function to free the `data`. Will be called once when `this_` is dropped. Can be NULL, in case if `data` is allocated in static memory.
        ///  @param context: An optional context to be passed to the `deleter`.
        ///
        ///  @return -1 if `start == NULL` and `len &gt; 0` (creating an empty slice), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_slice_from_buf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_slice_from_buf(z_owned_slice_t* @this, byte* data, nuint len, z_slice_from_buf_drop_delegate drop, void* context);

        /// <summary>
        ///  Frees memory and invalidates `z_owned_string_t`, putting it in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_string_drop(z_moved_string_t* this_);

        /// <summary>
        ///  @return ``true`` if `this_` is a valid string, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_string_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_string_check(z_owned_string_t* this_);

        /// <summary>
        ///  Constructs owned string in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_string_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_string_null(z_owned_string_t* this_);

        /// <summary>
        ///  @return ``true`` if view string is valid, ``false`` if it is in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_string_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_view_string_is_empty(z_view_string_t* this_);

        /// <summary>
        ///  Constructs an empty owned string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_string_empty(z_owned_string_t* this_);

        /// <summary>
        ///  Constructs an empty view string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_string_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_view_string_empty(z_view_string_t* this_);

        /// <summary>
        ///  Borrows string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_string_t* z_string_loan(z_owned_string_t* this_);

        /// <summary>
        ///  Borrows view string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_string_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_string_t* z_view_string_loan(z_view_string_t* this_);

        /// <summary>
        ///  Constructs an owned string by copying `str` into it (including terminating 0), using `strlen` (this should therefore not be used with untrusted inputs).
        ///
        ///  @return -1 if `str == NULL` (and creates a string in a gravestone state), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_copy_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_string_copy_from_str(z_owned_string_t* this_, byte* str);

        /// <summary>
        ///  Constructs an owned string by copying a `str` substring of length `len`.
        ///
        ///  @return -1 if `str == NULL` and `len &gt; 0` (and creates a string in a gravestone state), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_copy_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_string_copy_from_substr(z_owned_string_t* @this, byte* str, nuint len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_string_from_str_drop_delegate(void* value, void* context);

        /// <summary>
        ///  Constructs an owned string by transferring ownership of a null-terminated string `str` to it.
        ///  @param this_: Pointer to an uninitialized memory location where an owned string will be constructed.
        ///  @param str: Pointer to a null terminated string to be owned by `this_`.
        ///  @param drop: A thread-safe delete function to free the `str`. Will be called once when `str` is dropped. Can be NULL, in case if `str` is allocated in static memory.
        ///  @param context: An optional context to be passed to the `deleter`.
        ///  @return -1 if `str == NULL` and `len &gt; 0` (and creates a string in a gravestone state), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_string_from_str(z_owned_string_t* @this, byte* str, z_string_from_str_drop_delegate drop, void* context);

        /// <summary>
        ///  Constructs a view string of `str`, using `strlen` (this should therefore not be used with untrusted inputs).
        ///
        ///  @return -1 if `str == NULL` (and creates a string in a gravestone state), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_string_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_view_string_from_str(z_view_string_t* @this, byte* str);

        /// <summary>
        ///  Constructs a view string to a specified substring of length `len`.
        ///
        ///  @return -1 if `str == NULL` and `len &gt; 0` (and creates a string in a gravestone state), 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_view_string_from_substr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_view_string_from_substr(z_view_string_t* @this, byte* str, nuint len);

        /// <summary>
        ///  @return the length of the string (without terminating 0 character).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_string_len(z_loaned_string_t* this_);

        /// <summary>
        ///  @return the pointer of the string data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* z_string_data(z_loaned_string_t* this_);

        /// <summary>
        ///  Constructs an owned copy of a string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_string_clone(z_owned_string_t* dst, z_loaned_string_t* @this);

        [DllImport(__DllName, EntryPoint = "z_string_as_slice", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_slice_t* z_string_as_slice(z_loaned_string_t* this_);

        /// <summary>
        ///  @return ``true`` if string is empty, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_string_is_empty(z_loaned_string_t* this_);

        /// <summary>
        ///  Constructs a new empty string array.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_string_array_new(z_owned_string_array_t* this_);

        /// <summary>
        ///  Constructs string array in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_string_array_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_string_array_null(z_owned_string_array_t* this_);

        /// <summary>
        ///  @return ``true`` if the string array is valid, ``false`` if it is in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_string_array_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_string_array_check(z_owned_string_array_t* this_);

        /// <summary>
        ///  Destroys the string array, resetting it to its gravestone value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_string_array_drop(z_moved_string_array_t* this_);

        /// <summary>
        ///  Borrows string array.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_string_array_t* z_string_array_loan(z_owned_string_array_t* @this);

        /// <summary>
        ///  Mutably borrows string array.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_string_array_t* z_string_array_loan_mut(z_owned_string_array_t* @this);

        /// <summary>
        ///  @return number of elements in the array.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_string_array_len(z_loaned_string_array_t* this_);

        /// <summary>
        ///  @return ``true`` if the array is empty, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_string_array_is_empty(z_loaned_string_array_t* this_);

        /// <summary>
        ///  @return the value at the position of index in the string array.
        ///
        ///  Will return `NULL` if the index is out of bounds.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_get", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_string_t* z_string_array_get(z_loaned_string_array_t* @this, nuint index);

        /// <summary>
        ///  Appends specified value to the end of the string array by copying.
        ///
        ///  @return the new length of the array.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_push_by_copy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_string_array_push_by_copy(z_loaned_string_array_t* @this, z_loaned_string_t* value);

        /// <summary>
        ///  Appends specified value to the end of the string array by alias.
        ///
        ///  @return the new length of the array.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_push_by_alias", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern nuint z_string_array_push_by_alias(z_loaned_string_array_t* @this, z_loaned_string_t* value);

        /// <summary>
        ///  Constructs an owned copy of a string array.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_string_array_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_string_array_clone(z_owned_string_array_t* dst, z_loaned_string_array_t* this_);

        /// <summary>
        ///  Create uhlc timestamp from session id.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_timestamp_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_timestamp_new(z_timestamp_t* @this, z_loaned_session_t* session);

        /// <summary>
        ///  Returns NPT64 time associated with this timestamp.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_timestamp_ntp64_time", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_timestamp_ntp64_time(z_timestamp_t* this_);

        /// <summary>
        ///  @brief Returns id associated with this timestamp.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_timestamp_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_id_t z_timestamp_id(z_timestamp_t* this_);

        /// <summary>
        ///  Returns the key expression of the sample.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_keyexpr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_keyexpr_t* z_sample_keyexpr(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns the encoding associated with the sample data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_encoding", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_encoding_t* z_sample_encoding(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns the sample payload data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_payload", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_sample_payload(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns the mutable sample payload data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_payload_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_sample_payload_mut(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns the sample kind.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_kind", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_sample_kind_t z_sample_kind(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns the sample timestamp.
        ///
        ///  Will return `NULL`, if sample is not associated with a timestamp.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_timestamp", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_timestamp_t* z_sample_timestamp(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns sample attachment.
        ///
        ///  Returns `NULL`, if sample does not contain any attachment.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_attachment", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_bytes_t* z_sample_attachment(z_loaned_sample_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the sample source_info.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_source_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_source_info_t* z_sample_source_info(z_loaned_sample_t* this_);

        /// <summary>
        ///  Constructs an owned shallow copy of the sample (i.e. all modficiations applied to the copy, might be visible in the original) in provided uninitilized memory location.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_sample_clone(z_owned_sample_t* dst, z_loaned_sample_t* @this);

        /// <summary>
        ///  Returns sample qos priority value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_priority", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_priority_t z_sample_priority(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns whether sample qos express flag was set or not.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_express", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_sample_express(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns sample qos congestion control value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_congestion_control", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_congestion_control_t z_sample_congestion_control(z_loaned_sample_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the reliability setting the sample was delivered with.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_reliability", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_reliability_t z_sample_reliability(z_loaned_sample_t* this_);

        /// <summary>
        ///  Returns ``true`` if sample is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_sample_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_sample_check(z_owned_sample_t* this_);

        /// <summary>
        ///  Borrows sample.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_sample_t* z_sample_loan(z_owned_sample_t* this_);

        /// <summary>
        ///  Mutably borrows sample.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_sample_t* z_sample_loan_mut(z_owned_sample_t* this_);

        /// <summary>
        ///  Takes ownership of the mutably borrowed sample.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_take_from_loaned", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_sample_take_from_loaned(z_owned_sample_t* dst, z_loaned_sample_t* src);

        /// <summary>
        ///  Frees the memory and invalidates the sample, resetting it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sample_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_sample_drop(z_moved_sample_t* this_);

        /// <summary>
        ///  Constructs sample in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_sample_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_sample_null(z_owned_sample_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns default value of `zc_locality_t`
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_locality_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern zc_locality_t zc_locality_default();

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the default value for `reliability`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_reliability_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_reliability_t z_reliability_default();

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the default value of #zc_reply_keyexpr_t.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_reply_keyexpr_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern zc_reply_keyexpr_t zc_reply_keyexpr_default();

        /// <summary>
        ///  Create a default `z_query_target_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_query_target_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_query_target_t z_query_target_default();

        /// <summary>
        ///  Returns the default value of #z_priority_t.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_priority_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_priority_t z_priority_default();

        /// <summary>
        ///  Returns the default congestion control value of zenoh push network messages, typically used for put operations.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_congestion_control_default_push", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_congestion_control_t z_internal_congestion_control_default_push();

        /// <summary>
        ///  Returns the default congestion control value of zenoh request network messages, typically used for get operations.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_congestion_control_default_request", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_congestion_control_t z_internal_congestion_control_default_request();

        /// <summary>
        ///  Returns the default congestion control value of zenoh response network messages, typically used for reply operations.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_congestion_control_default_response", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_congestion_control_t z_internal_congestion_control_default_response();

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the zenoh id of entity global id.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_entity_global_id_zid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_id_t z_entity_global_id_zid(z_entity_global_id_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the entity id of the entity global id.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_entity_global_id_eid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint z_entity_global_id_eid(z_entity_global_id_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Creates source info.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_source_info_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_source_info_new(z_owned_source_info_t* @this, z_entity_global_id_t* source_id, uint source_sn);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the source_id of the source info.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_source_info_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_entity_global_id_t z_source_info_id(z_loaned_source_info_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns the source_sn of the source info.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_source_info_sn", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint z_source_info_sn(z_loaned_source_info_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns ``true`` if source info is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_source_info_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_source_info_check(z_owned_source_info_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Borrows source info.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_source_info_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_source_info_t* z_source_info_loan(z_owned_source_info_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Frees the memory and invalidates the source info, resetting it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_source_info_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_source_info_drop(z_moved_source_info_t* this_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs source info in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_source_info_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_source_info_null(z_owned_source_info_t* this_);

        /// <summary>
        ///  Drops the handler and resets it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_reply_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_fifo_handler_reply_drop(z_moved_fifo_handler_reply_t* this_);

        /// <summary>
        ///  Constructs a handler in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_fifo_handler_reply_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_fifo_handler_reply_null(z_owned_fifo_handler_reply_t* this_);

        /// <summary>
        ///  Returns ``true`` if handler is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_fifo_handler_reply_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_fifo_handler_reply_check(z_owned_fifo_handler_reply_t* this_);

        /// <summary>
        ///  Constructs send and recieve ends of the fifo channel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_channel_reply_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_fifo_channel_reply_new(z_owned_closure_reply_t* callback, z_owned_fifo_handler_reply_t* handler, nuint capacity);

        /// <summary>
        ///  Borrows handler.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_reply_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_fifo_handler_reply_t* z_fifo_handler_reply_loan(z_owned_fifo_handler_reply_t* @this);

        /// <summary>
        ///  Returns reply from the fifo buffer. If there are no more pending replies will block until next reply is received, or until
        ///  the channel is dropped (normally when all replies are received).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the reply will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_reply_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_fifo_handler_reply_recv(z_loaned_fifo_handler_reply_t* @this, z_owned_reply_t* reply);

        /// <summary>
        ///  Returns reply from the fifo buffer. If there are no more pending replies will return immediately (with reply set to its gravestone state).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the reply will be in the gravestone state),
        ///  `Z_CHANNEL_NODATA` if the channel is still alive, but its buffer is empty (the reply will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_reply_try_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_fifo_handler_reply_try_recv(z_loaned_fifo_handler_reply_t* @this, z_owned_reply_t* reply);

        /// <summary>
        ///  Drops the handler and resets it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_reply_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_ring_handler_reply_drop(z_moved_ring_handler_reply_t* this_);

        /// <summary>
        ///  Constructs a handler in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_ring_handler_reply_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_ring_handler_reply_null(z_owned_ring_handler_reply_t* this_);

        /// <summary>
        ///  Returns ``true`` if handler is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_ring_handler_reply_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_ring_handler_reply_check(z_owned_ring_handler_reply_t* this_);

        /// <summary>
        ///  Constructs send and recieve ends of the ring channel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_channel_reply_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_ring_channel_reply_new(z_owned_closure_reply_t* callback, z_owned_ring_handler_reply_t* handler, nuint capacity);

        /// <summary>
        ///  Borrows handler.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_reply_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_ring_handler_reply_t* z_ring_handler_reply_loan(z_owned_ring_handler_reply_t* @this);

        /// <summary>
        ///  Returns reply from the ring buffer. If there are no more pending replies will block until next reply is received, or until
        ///  the channel is dropped (normally when all replies are received).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the reply will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_reply_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_ring_handler_reply_recv(z_loaned_ring_handler_reply_t* @this, z_owned_reply_t* reply);

        /// <summary>
        ///  Returns reply from the ring buffer. If there are no more pending replies will return immediately (with reply set to its gravestone state).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the reply will be in the gravestone state),
        ///  `Z_CHANNEL_NODATA` if the channel is still alive, but its buffer is empty (the reply will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_reply_try_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_ring_handler_reply_try_recv(z_loaned_ring_handler_reply_t* @this, z_owned_reply_t* reply);

        /// <summary>
        ///  @brief Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_zid_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_closure_zid_check(z_owned_closure_zid_t* this_);

        /// <summary>
        ///  @brief Constructs a null closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_zid_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_closure_zid_null(z_owned_closure_zid_t* this_);

        /// <summary>
        ///  @brief Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_zid_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_zid_call(z_loaned_closure_zid_t* closure, z_id_t* z_id);

        /// <summary>
        ///  @brief Drops the closure, resetting it to its gravestone state. Droping an uninitialized (null) closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_zid_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_zid_drop(z_moved_closure_zid_t* closure_);

        /// <summary>
        ///  @brief Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_zid_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_zid_t* z_closure_zid_loan(z_owned_closure_zid_t* closure);

        /// <summary>
        ///  @brief Mutably borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_zid_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_zid_t* z_closure_zid_loan_mut(z_owned_closure_zid_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_zid_call_delegate(z_id_t* z_id, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_zid_drop_delegate(void* context);

        /// <summary>
        ///  @brief Constructs closure.
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_zid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_zid(z_owned_closure_zid_t* @this, z_closure_zid_call_delegate call, z_closure_zid_drop_delegate drop, void* context);

        /// <summary>
        ///  Constructs a closure in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_internal_closure_log_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_internal_closure_log_null(zc_owned_closure_log_t* this_);

        /// <summary>
        ///  Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_closure_log_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_closure_log_call(zc_loaned_closure_log_t* closure, zc_log_severity_t severity, z_loaned_string_t* msg);

        /// <summary>
        ///  Drops the closure. Droping an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_closure_log_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_closure_log_drop(zc_moved_closure_log_t* closure_);

        /// <summary>
        ///  Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_internal_closure_log_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool zc_internal_closure_log_check(zc_owned_closure_log_t* this_);

        /// <summary>
        ///  Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_closure_log_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern zc_loaned_closure_log_t* zc_closure_log_loan(zc_owned_closure_log_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void zc_closure_log_call_delegate(zc_log_severity_t severity, z_loaned_string_t* msg, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void zc_closure_log_drop_delegate(void* context);

        /// <summary>
        ///  @brief Constructs closure.
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "zc_closure_log", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void zc_closure_log(zc_owned_closure_log_t* @this, zc_closure_log_call_delegate call, zc_closure_log_drop_delegate drop, void* context);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs a null value of 'ze_owned_closure_miss_t' type
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_closure_miss_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_internal_closure_miss_null(ze_owned_closure_miss_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_internal_closure_miss_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool ze_internal_closure_miss_check(ze_owned_closure_miss_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_closure_miss_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_closure_miss_call(ze_loaned_closure_miss_t* closure, ze_miss_t* mathing_status);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Drops the closure, resetting it to its gravestone state. Droping an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_closure_miss_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_closure_miss_drop(ze_moved_closure_miss_t* closure_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_closure_miss_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ze_loaned_closure_miss_t* ze_closure_miss_loan(ze_owned_closure_miss_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void ze_closure_miss_call_delegate(ze_miss_t* matching_status, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void ze_closure_miss_drop_delegate(void* context);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @brief Constructs closure.
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ze_closure_miss", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ze_closure_miss(ze_owned_closure_miss_t* @this, ze_closure_miss_call_delegate call, ze_closure_miss_drop_delegate drop, void* context);

        /// <summary>
        ///  Constructs a closure in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_query_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_closure_query_null(z_owned_closure_query_t* this_);

        /// <summary>
        ///  Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_query_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_closure_query_check(z_owned_closure_query_t* this_);

        /// <summary>
        ///  Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_query_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_query_call(z_loaned_closure_query_t* closure, z_loaned_query_t* query);

        /// <summary>
        ///  Drops the closure, resetting it to its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_query_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_query_drop(z_moved_closure_query_t* closure_);

        /// <summary>
        ///  Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_query_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_query_t* z_closure_query_loan(z_owned_closure_query_t* closure);

        /// <summary>
        ///  Mutably borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_query_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_query_t* z_closure_query_loan_mut(z_owned_closure_query_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_query_call_delegate(z_loaned_query_t* query, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_query_drop_delegate(void* context);

        /// <summary>
        ///  @brief Constructs closure.
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_query", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_query(z_owned_closure_query_t* @this, z_closure_query_call_delegate call, z_closure_query_drop_delegate drop, void* context);

        /// <summary>
        ///  Constructs a closure int its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_reply_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_closure_reply_null(z_owned_closure_reply_t* this_);

        /// <summary>
        ///  Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_reply_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_closure_reply_check(z_owned_closure_reply_t* this_);

        /// <summary>
        ///  Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_reply_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_reply_call(z_loaned_closure_reply_t* closure, z_loaned_reply_t* reply);

        /// <summary>
        ///  Drops the closure, resetting it to its gravestone state. Droping an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_reply_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_reply_drop(z_moved_closure_reply_t* closure_);

        /// <summary>
        ///  Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_reply_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_reply_t* z_closure_reply_loan(z_owned_closure_reply_t* closure);

        /// <summary>
        ///  Mutably borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_reply_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_reply_t* z_closure_reply_loan_mut(z_owned_closure_reply_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_reply_call_delegate(z_loaned_reply_t* reply, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_reply_drop_delegate(void* context);

        /// <summary>
        ///  @brief Constructs closure.
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_reply", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_reply(z_owned_closure_reply_t* @this, z_closure_reply_call_delegate call, z_closure_reply_drop_delegate drop, void* context);

        /// <summary>
        ///  Constructs a closure in its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_sample_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_closure_sample_null(z_owned_closure_sample_t* this_);

        /// <summary>
        ///  Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_sample_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_closure_sample_check(z_owned_closure_sample_t* this_);

        /// <summary>
        ///  Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_sample_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_sample_call(z_loaned_closure_sample_t* closure, z_loaned_sample_t* sample);

        /// <summary>
        ///  Drops the closure. Droping an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_sample_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_sample_drop(z_moved_closure_sample_t* closure_);

        /// <summary>
        ///  Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_sample_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_sample_t* z_closure_sample_loan(z_owned_closure_sample_t* closure);

        /// <summary>
        ///  Mutably borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_sample_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_sample_t* z_closure_sample_loan_mut(z_owned_closure_sample_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_sample_call_delegate(z_loaned_sample_t* sample, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_sample_drop_delegate(void* context);

        /// <summary>
        ///  @brief Constructs closure.
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_sample", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_sample(z_owned_closure_sample_t* @this, z_closure_sample_call_delegate call, z_closure_sample_drop_delegate drop, void* context);

        /// <summary>
        ///  Constructs a closure in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_hello_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_closure_hello_null(z_owned_closure_hello_t* this_);

        /// <summary>
        ///  Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_hello_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_hello_call(z_loaned_closure_hello_t* closure, z_loaned_hello_t* hello);

        /// <summary>
        ///  Drops the closure. Droping an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_hello_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_hello_drop(z_moved_closure_hello_t* this_);

        /// <summary>
        ///  Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_hello_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_closure_hello_check(z_owned_closure_hello_t* this_);

        /// <summary>
        ///  Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_hello_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_hello_t* z_closure_hello_loan(z_owned_closure_hello_t* closure);

        /// <summary>
        ///  Mutably norrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_hello_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_hello_t* z_closure_hello_loan_mut(z_owned_closure_hello_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_hello_call_delegate(z_loaned_hello_t* hello, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_hello_drop_delegate(void* context);

        /// <summary>
        ///  @brief Constructs closure.
        ///  A closure is a structure that contains all the elements for stateful, memory-leak-free callbacks:
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_hello", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_hello(z_owned_closure_hello_t* @this, z_closure_hello_call_delegate call, z_closure_hello_drop_delegate drop, void* context);

        /// <summary>
        ///  Drops the handler and resets it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_query_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_fifo_handler_query_drop(z_moved_fifo_handler_query_t* this_);

        /// <summary>
        ///  Constructs a handler in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_fifo_handler_query_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_fifo_handler_query_null(z_owned_fifo_handler_query_t* this_);

        /// <summary>
        ///  Returns ``true`` if handler is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_fifo_handler_query_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_fifo_handler_query_check(z_owned_fifo_handler_query_t* this_);

        /// <summary>
        ///  Constructs send and recieve ends of the fifo channel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_channel_query_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_fifo_channel_query_new(z_owned_closure_query_t* callback, z_owned_fifo_handler_query_t* handler, nuint capacity);

        /// <summary>
        ///  Borrows handler.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_query_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_fifo_handler_query_t* z_fifo_handler_query_loan(z_owned_fifo_handler_query_t* @this);

        /// <summary>
        ///  Returns query from the fifo buffer. If there are no more pending queries will block until next query is received, or until
        ///  the channel is dropped (normally when Queryable is dropped).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the query will be in the gravestone state),
        ///  `Z_CHANNEL_NODATA` if the channel is still alive, but its buffer is empty (the query will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_query_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_fifo_handler_query_recv(z_loaned_fifo_handler_query_t* @this, z_owned_query_t* query);

        /// <summary>
        ///  Returns query from the fifo buffer. If there are no more pending queries will return immediately (with query set to its gravestone state).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the query will be in the gravestone state),
        ///  `Z_CHANNEL_NODATA` if the channel is still alive, but its buffer is empty (the query will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_query_try_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_fifo_handler_query_try_recv(z_loaned_fifo_handler_query_t* @this, z_owned_query_t* query);

        /// <summary>
        ///  Drops the handler and resets it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_query_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_ring_handler_query_drop(z_moved_ring_handler_query_t* this_);

        /// <summary>
        ///  Constructs a handler in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_ring_handler_query_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_ring_handler_query_null(z_owned_ring_handler_query_t* this_);

        /// <summary>
        ///  Returns ``true`` if handler is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_ring_handler_query_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_ring_handler_query_check(z_owned_ring_handler_query_t* this_);

        /// <summary>
        ///  Constructs send and recieve ends of the ring channel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_channel_query_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_ring_channel_query_new(z_owned_closure_query_t* callback, z_owned_ring_handler_query_t* handler, nuint capacity);

        /// <summary>
        ///  Borrows handler.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_query_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_ring_handler_query_t* z_ring_handler_query_loan(z_owned_ring_handler_query_t* @this);

        /// <summary>
        ///  Returns query from the ring buffer. If there are no more pending queries will block until next query is received, or until
        ///  the channel is dropped (normally when Queryable is dropped).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the query will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_query_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_ring_handler_query_recv(z_loaned_ring_handler_query_t* @this, z_owned_query_t* query);

        /// <summary>
        ///  Returns query from the ring buffer. If there are no more pending queries will return immediately (with query set to its gravestone state).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the query will be in the gravestone state),
        ///  Z_CHANNEL_NODATA if the channel is still alive, but its buffer is empty (the query will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_query_try_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_ring_handler_query_try_recv(z_loaned_ring_handler_query_t* @this, z_owned_query_t* query);

        /// <summary>
        ///  Drops the handler and resets it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_sample_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_fifo_handler_sample_drop(z_moved_fifo_handler_sample_t* this_);

        /// <summary>
        ///  Constructs a handler in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_fifo_handler_sample_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_fifo_handler_sample_null(z_owned_fifo_handler_sample_t* @this);

        /// <summary>
        ///  Returns ``true`` if handler is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_fifo_handler_sample_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_fifo_handler_sample_check(z_owned_fifo_handler_sample_t* this_);

        /// <summary>
        ///  Constructs send and recieve ends of the fifo channel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_channel_sample_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_fifo_channel_sample_new(z_owned_closure_sample_t* callback, z_owned_fifo_handler_sample_t* handler, nuint capacity);

        /// <summary>
        ///  Borrows handler.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_sample_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_fifo_handler_sample_t* z_fifo_handler_sample_loan(z_owned_fifo_handler_sample_t* @this);

        /// <summary>
        ///  Returns sample from the fifo buffer. If there are no more pending replies will block until next sample is received, or until
        ///  the channel is dropped (normally when there are no more samples to receive).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the sample will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_sample_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_fifo_handler_sample_recv(z_loaned_fifo_handler_sample_t* @this, z_owned_sample_t* sample);

        /// <summary>
        ///  Returns sample from the fifo buffer.
        ///  If there are no more pending replies will return immediately (with sample set to its gravestone state).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the sample will be in the gravestone state),
        ///  `Z_CHANNEL_NODATA` if the channel is still alive, but its buffer is empty (the sample will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_fifo_handler_sample_try_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_fifo_handler_sample_try_recv(z_loaned_fifo_handler_sample_t* @this, z_owned_sample_t* sample);

        /// <summary>
        ///  Drops the handler and resets it to a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_sample_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_ring_handler_sample_drop(z_moved_ring_handler_sample_t* this_);

        /// <summary>
        ///  Constructs a handler in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_ring_handler_sample_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_ring_handler_sample_null(z_owned_ring_handler_sample_t* @this);

        /// <summary>
        ///  Returns ``true`` if handler is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_ring_handler_sample_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_ring_handler_sample_check(z_owned_ring_handler_sample_t* this_);

        /// <summary>
        ///  Constructs send and recieve ends of the ring channel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_channel_sample_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_ring_channel_sample_new(z_owned_closure_sample_t* callback, z_owned_ring_handler_sample_t* handler, nuint capacity);

        /// <summary>
        ///  Borrows handler.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_sample_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_ring_handler_sample_t* z_ring_handler_sample_loan(z_owned_ring_handler_sample_t* @this);

        /// <summary>
        ///  Returns sample from the ring buffer. If there are no more pending replies will block until next sample is received, or until
        ///  the channel is dropped (normally when there are no more replies to receive).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the sample will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_sample_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_ring_handler_sample_recv(z_loaned_ring_handler_sample_t* @this, z_owned_sample_t* sample);

        /// <summary>
        ///  Returns sample from the ring buffer. If there are no more pending replies will return immediately (with sample set to its gravestone state).
        ///  @return 0 in case of success, `Z_CHANNEL_DISCONNECTED` if channel was dropped (the sample will be in the gravestone state),
        ///  `Z_CHANNEL_NODATA` if the channel is still alive, but its buffer is empty (the sample will be in the gravestone state).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_ring_handler_sample_try_recv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_ring_handler_sample_try_recv(z_loaned_ring_handler_sample_t* @this, z_owned_sample_t* sample);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Constructs a null value of 'z_owned_closure_matching_status_t' type
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_matching_status_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_closure_matching_status_null(z_owned_closure_matching_status_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Returns ``true`` if closure is valid, ``false`` if it is in gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_closure_matching_status_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_closure_matching_status_check(z_owned_closure_matching_status_t* @this);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Calls the closure. Calling an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_matching_status_call", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_matching_status_call(z_loaned_closure_matching_status_t* closure, z_matching_status_t* mathing_status);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Drops the closure, resetting it to its gravestone state. Droping an uninitialized closure is a no-op.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_matching_status_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_matching_status_drop(z_moved_closure_matching_status_t* closure_);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///  @brief Borrows closure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_matching_status_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_closure_matching_status_t* z_closure_matching_status_loan(z_owned_closure_matching_status_t* closure);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_matching_status_call_delegate(z_matching_status_t* matching_status, void* context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void z_closure_matching_status_drop_delegate(void* context);

        /// <summary>
        ///  @warning This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
        ///
        ///  Closures are not guaranteed not to be called concurrently.
        ///
        ///  It is guaranteed that:
        ///    - `call` will never be called once `drop` has started.
        ///    - `drop` will only be called **once**, and **after every** `call` has ended.
        ///    - The two previous guarantees imply that `call` and `drop` are never called concurrently.
        ///
        ///  @brief Constructs closure.
        ///  @param this_: uninitialized memory location where new closure will be constructed.
        ///  @param call: a closure body.
        ///  @param drop: an optional function to be called once on closure drop.
        ///  @param context: closure context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_closure_matching_status", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_closure_matching_status(z_owned_closure_matching_status_t* @this, z_closure_matching_status_call_delegate call, z_closure_matching_status_drop_delegate drop, void* context);

        /// <summary>
        ///  Generates random `uint8_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_random_u8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte z_random_u8();

        /// <summary>
        ///  Generates random `uint16_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_random_u16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ushort z_random_u16();

        /// <summary>
        ///  Generates random `uint32_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_random_u32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint z_random_u32();

        /// <summary>
        ///  Generates random `uint64_t`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_random_u64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_random_u64();

        /// <summary>
        ///  Fills buffer with random data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_random_fill", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_random_fill(void* buf, nuint len);

        /// <summary>
        ///  Returns monotonic clock time point corresponding to the current time instant.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_clock_now", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_clock_t z_clock_now();

        /// <summary>
        ///  Get number of seconds passed since creation of `time`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_clock_elapsed_s", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_clock_elapsed_s(z_clock_t* time);

        /// <summary>
        ///  Get number of milliseconds passed since creation of `time`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_clock_elapsed_ms", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_clock_elapsed_ms(z_clock_t* time);

        /// <summary>
        ///  Get number of microseconds passed since creation of `time`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_clock_elapsed_us", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_clock_elapsed_us(z_clock_t* time);

        /// <summary>
        ///  Converts current system time into null-terminated human readable string and writes it to the `buf`.
        ///
        ///  @param buf: A buffer where the string will be writtent
        ///  @param len: Maximum number of characters to write (including terminating 0). The string will be truncated
        ///  if it is longer than `len`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_time_now_as_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* z_time_now_as_str(byte* buf, nuint len);

        /// <summary>
        ///  Initialize clock with current time instant.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_time_now", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_time_t z_time_now();

        /// <summary>
        ///  Get number of seconds passed since creation of `time`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_time_elapsed_s", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_time_elapsed_s(z_time_t* time);

        /// <summary>
        ///  Get number of milliseconds passed since creation of `time`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_time_elapsed_ms", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_time_elapsed_ms(z_time_t* time);

        /// <summary>
        ///  Get number of microseconds passed since creation of `time`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_time_elapsed_us", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong z_time_elapsed_us(z_time_t* time);

        /// <summary>
        ///  Constructs a mutex.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_mutex_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_mutex_init(z_owned_mutex_t* this_);

        /// <summary>
        ///  Drops mutex and resets it to its gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_mutex_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_mutex_drop(z_moved_mutex_t* this_);

        /// <summary>
        ///  Returns ``true`` if mutex is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_mutex_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_mutex_check(z_owned_mutex_t* this_);

        /// <summary>
        ///  Constructs mutex in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_mutex_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_mutex_null(z_owned_mutex_t* this_);

        /// <summary>
        ///  Mutably borrows mutex.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_mutex_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_mutex_t* z_mutex_loan_mut(z_owned_mutex_t* this_);

        /// <summary>
        ///  Locks mutex. If mutex is already locked, blocks the thread until it aquires the lock.
        ///  @return 0 in case of success, negative error code in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_mutex_lock", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_mutex_lock(z_loaned_mutex_t* this_);

        /// <summary>
        ///  Unlocks previously locked mutex. If mutex was not locked by the current thread, the behaviour is undefined.
        ///  @return 0 in case of success, negative error code otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_mutex_unlock", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_mutex_unlock(z_loaned_mutex_t* this_);

        /// <summary>
        ///  Tries to lock mutex. If mutex is already locked, return immediately.
        ///  @return 0 in case of success, negative value if failed to aquire the lock.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_mutex_try_lock", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_mutex_try_lock(z_loaned_mutex_t* @this);

        /// <summary>
        ///  Constructs conditional variable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_condvar_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_condvar_init(z_owned_condvar_t* this_);

        /// <summary>
        ///  Constructs conditional variable in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_condvar_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_condvar_null(z_owned_condvar_t* this_);

        /// <summary>
        ///  Drops conditional variable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_condvar_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_condvar_drop(z_moved_condvar_t* this_);

        /// <summary>
        ///  Returns ``true`` if conditional variable is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_condvar_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_condvar_check(z_owned_condvar_t* this_);

        /// <summary>
        ///  Borrows conditional variable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_condvar_loan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_condvar_t* z_condvar_loan(z_owned_condvar_t* this_);

        /// <summary>
        ///  Mutably borrows conditional variable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_condvar_loan_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_loaned_condvar_t* z_condvar_loan_mut(z_owned_condvar_t* @this);

        /// <summary>
        ///  Wakes up one blocked thread waiting on this condiitonal variable.
        ///  @return 0 in case of success, negative error code in case of failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_condvar_signal", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_condvar_signal(z_loaned_condvar_t* this_);

        /// <summary>
        ///  Blocks the current thread until the conditional variable receives a notification.
        ///
        ///  The function atomically unlocks the guard mutex `m` and blocks the current thread.
        ///  When the function returns the lock will have been re-aquired again.
        ///  Note: The function may be subject to spurious wakeups.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_condvar_wait", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_condvar_wait(z_loaned_condvar_t* @this, z_loaned_mutex_t* m);

        /// <summary>
        ///  Constructs task in a gravestone state.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_task_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_internal_task_null(z_owned_task_t* this_);

        /// <summary>
        ///  Detaches the task and releases all allocated resources.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_task_detach", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_task_detach(z_moved_task_t* this_);

        /// <summary>
        ///  Joins the task and releases all allocated resources
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_task_join", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_task_join(z_moved_task_t* this_);

        /// <summary>
        ///  Drop the task. Same as `z_task_detach`. Use `z_task_join` to wait for the task completion.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_task_drop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void z_task_drop(z_moved_task_t* this_);

        /// <summary>
        ///  Returns ``true`` if task is valid, ``false`` otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_internal_task_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool z_internal_task_check(z_owned_task_t* this_);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void* z_task_init_fun_delegate(void* arg);

        /// <summary>
        ///  Constructs a new task.
        ///
        ///  @param this_: An uninitialized memory location where task will be constructed.
        ///  @param _attr: Attributes of the task (currently unused).
        ///  @param fun: Function to be executed by the task.
        ///  @param arg: Argument that will be passed to the function `fun`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_task_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_task_init(z_owned_task_t* @this, z_task_attr_t* _attr, z_task_init_fun_delegate fun, void* arg);

        /// <summary>
        ///  Puts current thread to sleep for specified amount of seconds.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sleep_s", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_sleep_s(nuint time);

        /// <summary>
        ///  Puts current thread to sleep for specified amount of milliseconds.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sleep_ms", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_sleep_ms(nuint time);

        /// <summary>
        ///  Puts current thread to sleep for specified amount of microseconds.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "z_sleep_us", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern z_result_t z_sleep_us(nuint time);


    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_queryable_options_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool complete;
        public zc_locality_t allowed_origin;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_query_reply_options_t
    {
        public z_moved_encoding_t* encoding;
        public z_congestion_control_t congestion_control;
        public z_priority_t priority;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
        public z_timestamp_t* timestamp;
        public z_moved_source_info_t* source_info;
        public z_moved_bytes_t* attachment;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_query_reply_err_options_t
    {
        public z_moved_encoding_t* encoding;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_query_reply_del_options_t
    {
        public z_congestion_control_t congestion_control;
        public z_priority_t priority;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
        public z_timestamp_t* timestamp;
        public z_moved_source_info_t* source_info;
        public z_moved_bytes_t* attachment;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_open_options_t
    {
        public byte _dummy;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_close_options_t
    {
        public uint internal_timeout_ms;
        public zc_owned_concurrent_close_handle_t* internal_out_concurrent;
        public byte _dummy;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_subscriber_options_t
    {
        public byte _0;
        public zc_locality_t allowed_origin;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct zc_internal_encoding_data_t
    {
        public ushort id;
        public byte* schema_ptr;
        public nuint schema_len;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_put_options_t
    {
        public z_moved_encoding_t* encoding;
        public z_congestion_control_t congestion_control;
        public z_priority_t priority;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
        public z_timestamp_t* timestamp;
        public z_reliability_t reliability;
        public zc_locality_t allowed_destination;
        public z_moved_source_info_t* source_info;
        public z_moved_bytes_t* attachment;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_delete_options_t
    {
        public z_congestion_control_t congestion_control;
        public z_priority_t priority;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
        public z_timestamp_t* timestamp;
        public z_reliability_t reliability;
        public zc_locality_t allowed_destination;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_publication_cache_options_t
    {
        public z_loaned_keyexpr_t* queryable_suffix;
        public zc_locality_t queryable_origin;
        [MarshalAs(UnmanagedType.U1)] public bool queryable_complete;
        public nuint history;
        public nuint resources_limit;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_get_options_t
    {
        public z_query_target_t target;
        public z_query_consolidation_t consolidation;
        public z_moved_bytes_t* payload;
        public z_moved_encoding_t* encoding;
        public z_congestion_control_t congestion_control;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
        public zc_locality_t allowed_destination;
        public zc_reply_keyexpr_t accept_replies;
        public z_priority_t priority;
        public z_moved_source_info_t* source_info;
        public z_moved_bytes_t* attachment;
        public ulong timeout_ms;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_query_consolidation_t
    {
        public z_consolidation_mode_t mode;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_liveliness_token_options_t
    {
        public byte _dummy;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_liveliness_subscriber_options_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool history;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_liveliness_get_options_t
    {
        public ulong timeout_ms;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_querying_subscriber_options_t
    {
        public zc_locality_t allowed_origin;
        public z_loaned_keyexpr_t* query_selector;
        public z_query_target_t query_target;
        public z_query_consolidation_t query_consolidation;
        public zc_reply_keyexpr_t query_accept_replies;
        public ulong query_timeout_ms;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_publisher_options_t
    {
        public z_moved_encoding_t* encoding;
        public z_congestion_control_t congestion_control;
        public z_priority_t priority;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
        public z_reliability_t reliability;
        public zc_locality_t allowed_destination;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_publisher_put_options_t
    {
        public z_moved_encoding_t* encoding;
        public z_timestamp_t* timestamp;
        public z_moved_source_info_t* source_info;
        public z_moved_bytes_t* attachment;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_publisher_delete_options_t
    {
        public z_timestamp_t* timestamp;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_scout_options_t
    {
        public ulong timeout_ms;
        public z_what_t what;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_subscriber_history_options_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool is_enabled;
        [MarshalAs(UnmanagedType.U1)] public bool detect_late_publishers;
        public nuint max_samples;
        public ulong max_age_ms;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_subscriber_last_sample_miss_detection_options_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool is_enabled;
        public ulong periodic_queries_period_ms;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_subscriber_recovery_options_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool is_enabled;
        public ze_advanced_subscriber_last_sample_miss_detection_options_t last_sample_miss_detection;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_subscriber_options_t
    {
        public z_subscriber_options_t subscriber_options;
        public ze_advanced_subscriber_history_options_t history;
        public ze_advanced_subscriber_recovery_options_t recovery;
        public ulong query_timeout_ms;
        [MarshalAs(UnmanagedType.U1)] public bool subscriber_detection;
        public z_loaned_keyexpr_t* subscriber_detection_metadata;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_miss_t
    {
        public z_entity_global_id_t source;
        public uint nb;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_querier_options_t
    {
        public z_query_target_t target;
        public z_query_consolidation_t consolidation;
        public z_congestion_control_t congestion_control;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
        public zc_locality_t allowed_destination;
        public zc_reply_keyexpr_t accept_replies;
        public z_priority_t priority;
        public ulong timeout_ms;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_querier_get_options_t
    {
        public z_moved_bytes_t* payload;
        public z_moved_encoding_t* encoding;
        public z_moved_source_info_t* source_info;
        public z_moved_bytes_t* attachment;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_publisher_cache_options_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool is_enabled;
        public nuint max_samples;
        public z_congestion_control_t congestion_control;
        public z_priority_t priority;
        [MarshalAs(UnmanagedType.U1)] public bool is_express;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_publisher_sample_miss_detection_options_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool is_enabled;
        public ulong heartbeat_period_ms;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_publisher_options_t
    {
        public z_publisher_options_t publisher_options;
        public ze_advanced_publisher_cache_options_t cache;
        public ze_advanced_publisher_sample_miss_detection_options_t sample_miss_detection;
        [MarshalAs(UnmanagedType.U1)] public bool publisher_detection;
        public z_loaned_keyexpr_t* publisher_detection_metadata;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_publisher_put_options_t
    {
        public z_publisher_put_options_t put_options;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_advanced_publisher_delete_options_t
    {
        public z_publisher_delete_options_t delete_options;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_matching_status_t
    {
        [MarshalAs(UnmanagedType.U1)] public bool matching;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_bytes_t
    {
        public fixed byte _0[40];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_bytes_t
    {
        public z_owned_bytes_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_bytes_t
    {
        public fixed byte _0[40];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_slice_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_slice_t
    {
        public z_owned_slice_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_view_slice_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_slice_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_string_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_string_t
    {
        public z_owned_string_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_view_string_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_string_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_string_array_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_string_array_t
    {
        public z_owned_string_array_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_string_array_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_sample_t
    {
        public fixed byte _0[232];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_sample_t
    {
        public z_owned_sample_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_sample_t
    {
        public fixed byte _0[232];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_bytes_reader_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_bytes_writer_t
    {
        public fixed byte _0[64];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_bytes_writer_t
    {
        public z_owned_bytes_writer_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_bytes_writer_t
    {
        public fixed byte _0[64];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_bytes_slice_iterator_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_encoding_t
    {
        public fixed byte _0[48];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_encoding_t
    {
        public z_owned_encoding_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_encoding_t
    {
        public fixed byte _0[48];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_reply_t
    {
        public fixed byte _0[256];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_reply_t
    {
        public z_owned_reply_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_reply_t
    {
        public fixed byte _0[256];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_reply_err_t
    {
        public fixed byte _0[88];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_reply_err_t
    {
        public z_owned_reply_err_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_reply_err_t
    {
        public fixed byte _0[88];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_query_t
    {
        public fixed byte _0[144];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_query_t
    {
        public z_owned_query_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_query_t
    {
        public fixed byte _0[144];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_queryable_t
    {
        public fixed byte _0[16];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_queryable_t
    {
        public z_owned_queryable_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_queryable_t
    {
        public fixed byte _0[16];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_querier_t
    {
        public fixed byte _0[80];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_querier_t
    {
        public z_owned_querier_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_querier_t
    {
        public fixed byte _0[80];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_owned_querying_subscriber_t
    {
        public fixed byte _0[80];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_moved_querying_subscriber_t
    {
        public ze_owned_querying_subscriber_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_loaned_querying_subscriber_t
    {
        public fixed byte _0[80];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_owned_advanced_subscriber_t
    {
        public fixed byte _0[152];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_moved_advanced_subscriber_t
    {
        public ze_owned_advanced_subscriber_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_loaned_advanced_subscriber_t
    {
        public fixed byte _0[152];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_owned_sample_miss_listener_t
    {
        public fixed byte _0[16];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_moved_sample_miss_listener_t
    {
        public ze_owned_sample_miss_listener_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_owned_advanced_publisher_t
    {
        public fixed byte _0[200];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_moved_advanced_publisher_t
    {
        public ze_owned_advanced_publisher_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_loaned_advanced_publisher_t
    {
        public fixed byte _0[200];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_keyexpr_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_keyexpr_t
    {
        public z_owned_keyexpr_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_view_keyexpr_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_keyexpr_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_session_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_session_t
    {
        public z_owned_session_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_session_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct zc_owned_concurrent_close_handle_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct zc_moved_concurrent_close_handle_t
    {
        public zc_owned_concurrent_close_handle_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_config_t
    {
        public fixed byte _0[1864];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_config_t
    {
        public z_owned_config_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_config_t
    {
        public fixed byte _0[1864];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_id_t
    {
        public fixed byte id[16];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_timestamp_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_publisher_t
    {
        public fixed byte _0[112];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_publisher_t
    {
        public z_owned_publisher_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_publisher_t
    {
        public fixed byte _0[112];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_matching_listener_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_matching_listener_t
    {
        public z_owned_matching_listener_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_subscriber_t
    {
        public fixed byte _0[48];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_subscriber_t
    {
        public z_owned_subscriber_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_subscriber_t
    {
        public fixed byte _0[48];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_liveliness_token_t
    {
        public fixed byte _0[16];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_liveliness_token_t
    {
        public z_owned_liveliness_token_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_liveliness_token_t
    {
        public fixed byte _0[16];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_owned_publication_cache_t
    {
        public fixed byte _0[96];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_moved_publication_cache_t
    {
        public ze_owned_publication_cache_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_loaned_publication_cache_t
    {
        public fixed byte _0[96];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_mutex_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_mutex_t
    {
        public z_owned_mutex_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_mutex_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_condvar_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_condvar_t
    {
        public z_owned_condvar_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_condvar_t
    {
        public fixed byte _0[16];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_task_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_task_t
    {
        public z_owned_task_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_hello_t
    {
        public fixed byte _0[48];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_hello_t
    {
        public z_owned_hello_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_hello_t
    {
        public fixed byte _0[48];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_shm_client_storage_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_shm_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_shm_t
    {
        public z_owned_shm_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_shm_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_shm_mut_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_shm_mut_t
    {
        public z_owned_shm_mut_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_fifo_handler_sample_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_fifo_handler_sample_t
    {
        public z_owned_fifo_handler_sample_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_fifo_handler_sample_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_ring_handler_sample_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_ring_handler_sample_t
    {
        public z_owned_ring_handler_sample_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_ring_handler_sample_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_fifo_handler_query_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_fifo_handler_query_t
    {
        public z_owned_fifo_handler_query_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_fifo_handler_query_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_ring_handler_query_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_ring_handler_query_t
    {
        public z_owned_ring_handler_query_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_ring_handler_query_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_fifo_handler_reply_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_fifo_handler_reply_t
    {
        public z_owned_fifo_handler_reply_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_fifo_handler_reply_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_ring_handler_reply_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_ring_handler_reply_t
    {
        public z_owned_ring_handler_reply_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_ring_handler_reply_t
    {
        public fixed byte _0[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_source_info_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_source_info_t
    {
        public z_owned_source_info_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_source_info_t
    {
        public fixed byte _0[32];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_entity_global_id_t
    {
        public fixed byte _0[20];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_owned_serializer_t
    {
        public fixed byte _0[64];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_moved_serializer_t
    {
        public ze_owned_serializer_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_loaned_serializer_t
    {
        public fixed byte _0[64];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_deserializer_t
    {
        public fixed byte _0[24];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_closure_zid_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_closure_zid_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_closure_zid_t
    {
        public z_owned_closure_zid_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct zc_owned_closure_log_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct zc_loaned_closure_log_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct zc_moved_closure_log_t
    {
        public zc_owned_closure_log_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_owned_closure_miss_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_loaned_closure_miss_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ze_moved_closure_miss_t
    {
        public ze_owned_closure_miss_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_closure_query_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_closure_query_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_closure_query_t
    {
        public z_owned_closure_query_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_closure_reply_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_closure_reply_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_closure_reply_t
    {
        public z_owned_closure_reply_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_closure_sample_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_closure_sample_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_closure_sample_t
    {
        public z_owned_closure_sample_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_closure_hello_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_closure_hello_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_closure_hello_t
    {
        public z_owned_closure_hello_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_owned_closure_matching_status_t
    {
        public void* _context;
        public void* _call;
        public void* _drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_loaned_closure_matching_status_t
    {
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ _0[3];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_moved_closure_matching_status_t
    {
        public z_owned_closure_matching_status_t _this;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_clock_t
    {
        public ulong t;
        public void* t_base;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_time_t
    {
        public ulong t;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct z_task_attr_t
    {
        public nuint Item1;
    }


    internal enum z_whatami_t : uint
    {
        ROUTER = 1,
        PEER = 2,
        CLIENT = 4,
    }

    internal enum z_what_t : uint
    {
        ROUTER = 1,
        PEER = 2,
        CLIENT = 4,
        ROUTER_PEER,
        ROUTER_CLIENT,
        PEER_CLIENT,
        ROUTER_PEER_CLIENT,
    }

    internal enum z_keyexpr_intersection_level_t : uint
    {
        DISJOINT = 0,
        INTERSECTS = 1,
        INCLUDES = 2,
        EQUALS = 3,
    }

    internal enum z_sample_kind_t : uint
    {
        PUT = 0,
        DELETE = 1,
    }

    internal enum zc_locality_t : uint
    {
        ANY = 0,
        SESSION_LOCAL = 1,
        REMOTE = 2,
    }

    internal enum z_reliability_t : uint
    {
        BEST_EFFORT,
        RELIABLE,
    }

    internal enum zc_reply_keyexpr_t : uint
    {
        ANY = 0,
        MATCHING_QUERY = 1,
    }

    internal enum z_query_target_t : uint
    {
        BEST_MATCHING,
        ALL,
        ALL_COMPLETE,
    }

    internal enum z_consolidation_mode_t : int
    {
        AUTO = -1,
        NONE = 0,
        MONOTONIC = 1,
        LATEST = 2,
    }

    internal enum z_priority_t : uint
    {
        REAL_TIME = 1,
        INTERACTIVE_HIGH = 2,
        INTERACTIVE_LOW = 3,
        DATA_HIGH = 4,
        DATA = 5,
        DATA_LOW = 6,
        BACKGROUND = 7,
    }

    internal enum z_congestion_control_t : uint
    {
        BLOCK,
        DROP,
    }

    internal enum zc_log_severity_t : uint
    {
        TRACE = 0,
        DEBUG = 1,
        INFO = 2,
        WARN = 3,
        ERROR = 4,
    }

    internal enum z_result_t : sbyte
    {
        Z_XXXXXX = 100,
        Z_CHANNEL_DISCONNECTED = 1,
        Z_CHANNEL_NODATA = 2,
        Z_OK = 0,
        Z_EINVAL = -1,
        Z_EPARSE = -2,
        Z_EIO = -3,
        Z_ENETWORK = -4,
        Z_ENULL = -5,
        Z_EUNAVAILABLE = -6,
        Z_EDESERIALIZE = -7,
        Z_ESESSION_CLOSED = -8,
        Z_EUTF8 = -9,
        Z_EBUSY_MUTEX = -16,
        Z_EINVAL_MUTEX = -22,
        Z_EAGAIN_MUTEX = -11,
        Z_EPOISON_MUTEX = -22,
        Z_EGENERIC = -128,
    }


}
#endif
